Help on module babel.localedata in babel:

NAME
    babel.localedata

DESCRIPTION
    babel.localedata
    ~~~~~~~~~~~~~~~~
    
    Low-level locale data access.
    
    :note: The `Locale` class, which uses this module under the hood, provides a
           more convenient interface for accessing the locale data.
    
    :copyright: (c) 2013-2018 by the Babel Team.
    :license: BSD, see LICENSE for more details.

CLASSES
    builtins.object
        Alias
    collections.abc.MutableMapping(collections.abc.Mapping)
        LocaleDataDict
    
    class Alias(builtins.object)
     |  Representation of an alias in the locale data.
     |  
     |  An alias is a value that refers to some other part of the locale data,
     |  as specified by the `keys`.
     |  
     |  Methods defined here:
     |  
     |  __init__(self, keys)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  __repr__(self)
     |      Return repr(self).
     |  
     |  resolve(self, data)
     |      Resolve the alias based on the given data.
     |      
     |      This is done recursively, so if one alias resolves to a second alias,
     |      that second alias will also be resolved.
     |      
     |      :param data: the locale data
     |      :type data: `dict`
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class LocaleDataDict(collections.abc.MutableMapping)
     |  Dictionary wrapper that automatically resolves aliases to the actual
     |  values.
     |  
     |  Method resolution order:
     |      LocaleDataDict
     |      collections.abc.MutableMapping
     |      collections.abc.Mapping
     |      collections.abc.Collection
     |      collections.abc.Sized
     |      collections.abc.Iterable
     |      collections.abc.Container
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __delitem__(self, key)
     |  
     |  __getitem__(self, key)
     |  
     |  __init__(self, data, base=None)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  __iter__(self)
     |  
     |  __len__(self)
     |  
     |  __setitem__(self, key, value)
     |  
     |  copy(self)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __abstractmethods__ = frozenset()
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from collections.abc.MutableMapping:
     |  
     |  clear(self)
     |      D.clear() -> None.  Remove all items from D.
     |  
     |  pop(self, key, default=<object object at 0x106243050>)
     |      D.pop(k[,d]) -> v, remove specified key and return the corresponding value.
     |      If key is not found, d is returned if given, otherwise KeyError is raised.
     |  
     |  popitem(self)
     |      D.popitem() -> (k, v), remove and return some (key, value) pair
     |      as a 2-tuple; but raise KeyError if D is empty.
     |  
     |  setdefault(self, key, default=None)
     |      D.setdefault(k[,d]) -> D.get(k,d), also set D[k]=d if k not in D
     |  
     |  update(*args, **kwds)
     |      D.update([E, ]**F) -> None.  Update D from mapping/iterable E and F.
     |      If E present and has a .keys() method, does:     for k in E: D[k] = E[k]
     |      If E present and lacks .keys() method, does:     for (k, v) in E: D[k] = v
     |      In either case, this is followed by: for k, v in F.items(): D[k] = v
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from collections.abc.Mapping:
     |  
     |  __contains__(self, key)
     |  
     |  __eq__(self, other)
     |      Return self==value.
     |  
     |  get(self, key, default=None)
     |      D.get(k[,d]) -> D[k] if k in D, else d.  d defaults to None.
     |  
     |  items(self)
     |      D.items() -> a set-like object providing a view on D's items
     |  
     |  keys(self)
     |      D.keys() -> a set-like object providing a view on D's keys
     |  
     |  values(self)
     |      D.values() -> an object providing a view on D's values
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from collections.abc.Mapping:
     |  
     |  __hash__ = None
     |  
     |  __reversed__ = None
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from collections.abc.Collection:
     |  
     |  __subclasshook__(C) from abc.ABCMeta
     |      Abstract classes can override this to customize issubclass().
     |      
     |      This is invoked early on by abc.ABCMeta.__subclasscheck__().
     |      It should return True, False or NotImplemented.  If it returns
     |      NotImplemented, the normal algorithm is used.  Otherwise, it
     |      overrides the normal algorithm (and the outcome is cached).

FUNCTIONS
    exists(name)
        Check whether locale data is available for the given locale.
        
        Returns `True` if it exists, `False` otherwise.
        
        :param name: the locale identifier string
    
    load(name, merge_inherited=True)
        Load the locale data for the given locale.
        
        The locale data is a dictionary that contains much of the data defined by
        the Common Locale Data Repository (CLDR). This data is stored as a
        collection of pickle files inside the ``babel`` package.
        
        >>> d = load('en_US')
        >>> d['languages']['sv']
        u'Swedish'
        
        Note that the results are cached, and subsequent requests for the same
        locale return the same dictionary:
        
        >>> d1 = load('en_US')
        >>> d2 = load('en_US')
        >>> d1 is d2
        True
        
        :param name: the locale identifier string (or "root")
        :param merge_inherited: whether the inherited data should be merged into
                                the data of the requested locale
        :raise `IOError`: if no locale data file is found for the given locale
                          identifer, or one of the locales it inherits from
    
    locale_identifiers()
        Return a list of all locale identifiers for which locale data is
        available.
        
        .. versionadded:: 0.8.1
        
        :return: a list of locale identifiers (strings)
    
    merge(dict1, dict2)
        Merge the data from `dict2` into the `dict1` dictionary, making copies
        of nested dictionaries.
        
        >>> d = {1: 'foo', 3: 'baz'}
        >>> merge(d, {1: 'Foo', 2: 'Bar'})
        >>> sorted(d.items())
        [(1, 'Foo'), (2, 'Bar'), (3, 'baz')]
        
        :param dict1: the dictionary to merge into
        :param dict2: the dictionary containing the data that should be merged
    
    normalize_locale(name)
        Normalize a locale ID by stripping spaces and apply proper casing.
        
        Returns the normalized locale ID string or `None` if the ID is not
        recognized.

DATA
    string_types = (<class 'str'>,)

FILE
    /Users/jack/miniconda2/envs/py37/lib/python3.6/site-packages/babel/localedata.py


