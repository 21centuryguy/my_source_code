Help on module py2app.build_app in py2app:

NAME
    py2app.build_app - Mac OS X .app build command for distutils

DESCRIPTION
    Originally (loosely) based on code from py2exe's build_exe.py by Thomas Heller.

CLASSES
    builtins.object
        Target
    macholib.MachOStandalone.MachOStandalone(builtins.object)
        PythonStandalone
    setuptools.Command(distutils.cmd.Command)
        py2app
    
    class PythonStandalone(macholib.MachOStandalone.MachOStandalone)
     |  Method resolution order:
     |      PythonStandalone
     |      macholib.MachOStandalone.MachOStandalone
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, appbuilder, ext_dir, copyexts, *args, **kwargs)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  copy_dylib(self, src)
     |  
     |  copy_framework(self, info)
     |  
     |  update_node(self, m)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from macholib.MachOStandalone.MachOStandalone:
     |  
     |  getClass(self, name, cls)
     |  
     |  locate(self, filename, loader=None)
     |  
     |  mergecopy(self, src, dest)
     |  
     |  mergetree(self, src, dest)
     |  
     |  run(self, platfiles=None, contents=None)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from macholib.MachOStandalone.MachOStandalone:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class Target(builtins.object)
     |  # A very loosely defined "target".  We assume either a "script" or "modules"
     |  # attribute.  Some attributes will be target specific.
     |  
     |  Methods defined here:
     |  
     |  __init__(self, **kw)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  get_dest_base(self)
     |  
     |  validate(self)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class py2app(setuptools.Command)
     |  Abstract base class for defining command classes, the "worker bees"
     |  of the Distutils.  A useful analogy for command classes is to think of
     |  them as subroutines with local variables called "options".  The options
     |  are "declared" in 'initialize_options()' and "defined" (given their
     |  final values, aka "finalized") in 'finalize_options()', both of which
     |  must be defined by every command class.  The distinction between the
     |  two is necessary because option values might come from the outside
     |  world (command line, config file, ...), and any options dependent on
     |  other options must be computed *after* these outside influences have
     |  been processed -- hence 'finalize_options()'.  The "body" of the
     |  subroutine, where it does all its work based on the values of its
     |  options, is the 'run()' method, which must also be implemented by every
     |  command class.
     |  
     |  Method resolution order:
     |      py2app
     |      setuptools.Command
     |      distutils.cmd.Command
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  build_alias_executable(self, target, script, extra_scripts)
     |  
     |  build_executable(self, target, arcname, pkgexts, copyexts, script, extra_scripts)
     |  
     |  build_graph(self, mf, flatpackages)
     |  
     |  build_xref(self, mf, flatpackages)
     |  
     |  collect_filters(self)
     |  
     |  collect_packagedirs(self)
     |  
     |  collect_recipedict(self)
     |  
     |  collect_scripts(self)
     |  
     |  compile_datamodels(self, resdir)
     |  
     |  compile_mappingmodels(self, resdir)
     |  
     |  copy_dylib(self, src, dst)
     |  
     |  copy_file(self, infile, outfile)
     |      This version doesn't bork on existing symlinks
     |  
     |  copy_framework(self, info, dst)
     |  
     |  copy_package_data(self, package, target_dir)
     |      Copy any package data in a python package into the target_dir.
     |      
     |      This is a bit of a hack, it would be better to identify python eggs
     |      and copy those in whole.
     |  
     |  copy_python_framework(self, info, dst)
     |  
     |  copy_tree(self, infile, outfile, preserve_mode=1, preserve_times=1, preserve_symlinks=0, level=1, condition=None)
     |      Copy an entire directory tree respecting verbose, dry-run,
     |      and force flags.
     |      
     |      This version doesn't bork on existing symlinks
     |  
     |  copy_versioned_framework(self, info, dst)
     |  
     |  create_appbundle(self, target, script, use_runtime_preference=True)
     |  
     |  create_binaries(self, py_files, pkgdirs, extensions, loader_files)
     |  
     |  create_bundle(self, target, script, use_runtime_preference=True)
     |  
     |  create_directories(self)
     |  
     |  create_loader(self, item)
     |  
     |  create_pluginbundle(self, target, script, use_runtime_preference=True)
     |  
     |  filter_dependencies(self, mf, filters)
     |  
     |  finalize_modulefinder(self, mf)
     |  
     |  finalize_options(self)
     |      Set final values for all the options that this command supports.
     |      This is always called as late as possible, ie.  after any option
     |      assignments from the command-line or from other commands have been
     |      done.  Thus, this is the place to code option dependencies: if
     |      'foo' depends on 'bar', then it is safe to set 'foo' from 'bar' as
     |      long as 'foo' still has the same value it was assigned in
     |      'initialize_options()'.
     |      
     |      This method must be implemented by all command classes.
     |  
     |  fixup_distribution(self)
     |  
     |  get_appname(self)
     |  
     |  get_bootstrap(self, bootstrap)
     |  
     |  get_bootstrap_data(self, bootstrap)
     |  
     |  get_default_plist(self)
     |  
     |  get_modulefinder(self)
     |  
     |  get_plist_options(self)
     |  
     |  get_runtime(self, prefix=None, version=None)
     |  
     |  get_runtime_preferences(self, prefix=None, version=None)
     |  
     |  initialize_options(self)
     |      Set default values for all the options that this command
     |      supports.  Note that these defaults may be overridden by other
     |      commands, by the setup script, by config files, or by the
     |      command-line.  Thus, this is not the place to code dependencies
     |      between options; generally, 'initialize_options()' implementations
     |      are just a bunch of "self.foo = None" assignments.
     |      
     |      This method must be implemented by all command classes.
     |  
     |  initialize_plist(self)
     |  
     |  initialize_prescripts(self)
     |  
     |  iter_data_files(self)
     |  
     |  iter_datamodels(self, resdir)
     |  
     |  iter_extra_plugins(self)
     |  
     |  iter_frameworks(self)
     |  
     |  iter_mappingmodels(self, resdir)
     |  
     |  make_lib_archive(self, zip_filename, base_dir, verbose=0, dry_run=0)
     |  
     |  may_log_missing(self, module_name)
     |  
     |  process_recipes(self, mf, filters, flatpackages, loader_files)
     |  
     |  raw_copy_framework(self, info, dst)
     |  
     |  read_expected_missing_imports_file(self, filename)
     |  
     |  run(self)
     |      A command's raison d'etre: carry out the action it exists to
     |      perform, controlled by the options initialized in
     |      'initialize_options()', customized by other commands, the setup
     |      script, the command-line, and config files, and finalized in
     |      'finalize_options()'.  All terminal output and filesystem
     |      interaction should be done by 'run()'.
     |      
     |      This method must be implemented by all command classes.
     |  
     |  run_alias(self)
     |  
     |  run_normal(self)
     |  
     |  strip_dsym(self, platfiles)
     |      Remove .dSYM directories in the bundled application
     |  
     |  strip_files(self, files)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  always_expected_missing_imports = {'_frozen_importlib_external', 'java...
     |  
     |  boolean_options = ['xref', 'strip', 'no-strip', 'site-packages', 'semi...
     |  
     |  description = 'create a Mac OS X application or plugin from Python scr...
     |  
     |  user_options = [('app=', None, 'application bundle to be built'), ('pl...
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from setuptools.Command:
     |  
     |  __init__(self, dist, **kw)
     |      Construct the command for dist, updating
     |      vars(self) with any keyword parameters.
     |  
     |  reinitialize_command(self, command, reinit_subcommands=0, **kw)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from setuptools.Command:
     |  
     |  command_consumes_arguments = False
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from distutils.cmd.Command:
     |  
     |  __getattr__(self, attr)
     |      # XXX A more explicit way to customize dry_run would be better.
     |  
     |  announce(self, msg, level=1)
     |      If the current verbosity level is of greater than or equal to
     |      'level' print 'msg' to stdout.
     |  
     |  debug_print(self, msg)
     |      Print 'msg' to stdout if the global DEBUG (taken from the
     |      DISTUTILS_DEBUG environment variable) flag is true.
     |  
     |  dump_options(self, header=None, indent='')
     |  
     |  ensure_dirname(self, option)
     |  
     |  ensure_filename(self, option)
     |      Ensure that 'option' is the name of an existing file.
     |  
     |  ensure_finalized(self)
     |  
     |  ensure_string(self, option, default=None)
     |      Ensure that 'option' is a string; if not defined, set it to
     |      'default'.
     |  
     |  ensure_string_list(self, option)
     |      Ensure that 'option' is a list of strings.  If 'option' is
     |      currently a string, we split it either on /,\s*/ or /\s+/, so
     |      "foo bar baz", "foo,bar,baz", and "foo,   bar baz" all become
     |      ["foo", "bar", "baz"].
     |  
     |  execute(self, func, args, msg=None, level=1)
     |  
     |  get_command_name(self)
     |  
     |  get_finalized_command(self, command, create=1)
     |      Wrapper around Distribution's 'get_command_obj()' method: find
     |      (create if necessary and 'create' is true) the command object for
     |      'command', call its 'ensure_finalized()' method, and return the
     |      finalized command object.
     |  
     |  get_sub_commands(self)
     |      Determine the sub-commands that are relevant in the current
     |      distribution (ie., that need to be run).  This is based on the
     |      'sub_commands' class attribute: each tuple in that list may include
     |      a method that we call to determine if the subcommand needs to be
     |      run for the current distribution.  Return a list of command names.
     |  
     |  make_archive(self, base_name, format, root_dir=None, base_dir=None, owner=None, group=None)
     |  
     |  make_file(self, infiles, outfile, func, args, exec_msg=None, skip_msg=None, level=1)
     |      Special case of 'execute()' for operations that process one or
     |      more input files and generate one output file.  Works just like
     |      'execute()', except the operation is skipped and a different
     |      message printed if 'outfile' already exists and is newer than all
     |      files listed in 'infiles'.  If the command defined 'self.force',
     |      and it is true, then the command is unconditionally run -- does no
     |      timestamp checks.
     |  
     |  mkpath(self, name, mode=511)
     |  
     |  move_file(self, src, dst, level=1)
     |      Move a file respecting dry-run flag.
     |  
     |  run_command(self, command)
     |      Run some other command: uses the 'run_command()' method of
     |      Distribution, which creates and finalizes the command object if
     |      necessary and then invokes its 'run()' method.
     |  
     |  set_undefined_options(self, src_cmd, *option_pairs)
     |      Set the values of any "undefined" options from corresponding
     |      option values in some other command object.  "Undefined" here means
     |      "is None", which is the convention used to indicate that an option
     |      has not been changed between 'initialize_options()' and
     |      'finalize_options()'.  Usually called from 'finalize_options()' for
     |      options that depend on some other command rather than another
     |      option of the same command.  'src_cmd' is the other command from
     |      which option values will be taken (a command object will be created
     |      for it if necessary); the remaining arguments are
     |      '(src_option,dst_option)' tuples which mean "take the value of
     |      'src_option' in the 'src_cmd' command object, and copy it to
     |      'dst_option' in the current command object".
     |  
     |  spawn(self, cmd, search_path=1, level=1)
     |      Spawn an external command respecting dry-run flag.
     |  
     |  warn(self, msg)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from distutils.cmd.Command:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from distutils.cmd.Command:
     |  
     |  sub_commands = []

FUNCTIONS
    FixupTargets(targets, default_attribute)
    
    framework_copy_condition(src)
    
    get_zipfile(dist, semi_standalone=False)
    
    installation_info(version=None)
    
    is_system()
    
    iterRecipes(module=<module 'py2app.recipes' from '/Users/jack/miniconda2/envs/py37/lib/python3.6/site-packages/py2app/recipes/__init__.py'>)
    
    normalize_data_file(fn)
    
    rewrite_tkinter_load_commands(tkinter_path)
    
    validate_target(dist, attr, value)

DATA
    PLUGIN_SUFFIXES = {'.action': 'Automator', '.iaplugin': 'InternetAccou...
    PYTHONFRAMEWORK = ''
    print_function = _Feature((2, 6, 0, 'alpha', 2), (3, 0, 0, 'alpha', 0)...
    sys_base_prefix = '/Users/jack/miniconda2/envs/py37'

FILE
    /Users/jack/miniconda2/envs/py37/lib/python3.6/site-packages/py2app/build_app.py


