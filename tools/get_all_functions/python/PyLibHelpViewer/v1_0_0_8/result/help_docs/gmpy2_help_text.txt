Help on module gmpy2:

NAME
    gmpy2 - gmpy2 2.0.8 - General Multiple-precision arithmetic for Python

DESCRIPTION
    gmpy2 supports several multiple-precision libraries. Integer and
    rational arithmetic is provided by either the GMP or MPIR libraries.
    Real floating-point arithmetic is provided by the MPFR library.
    Complex floating-point arithmetic is provided by the MPC library.
    
    The integer type 'mpz' has comparable functionality to Python's
    builtin integers, but is faster for operations on large numbers.
    A wide variety of additional functions are provided:
          - bit manipulations
          - GCD, Extended GCD, LCM
          - Fibonacci and Lucas sequences
          - primality testing
          - powers and integer Nth roots
    
    The rational type 'mpq' is equivalent to Python's fractions
    module, but is faster.
    
    The real type 'mpfr' and complex type 'mpc' provide multiple-
    precision real and complex numbers with user-definable precision,
    rounding, and exponent range. All the advanced functions from the
    MPFR and MPC libraries are available.

CLASSES
    builtins.ValueError(builtins.Exception)
        InvalidOperationError(gmpyError, builtins.ValueError)
    builtins.ZeroDivisionError(builtins.ArithmeticError)
        DivisionByZeroError(gmpyError, builtins.ZeroDivisionError)
    gmpyError(builtins.ArithmeticError)
        DivisionByZeroError(gmpyError, builtins.ZeroDivisionError)
        ExponentOutOfBoundsError
        InexactResultError
            OverflowResultError
            UnderflowResultError
        InvalidOperationError(gmpyError, builtins.ValueError)
        RangeError
    
    class DivisionByZeroError(gmpyError, builtins.ZeroDivisionError)
     |  Second argument to a division or modulo operation was zero.
     |  
     |  Method resolution order:
     |      DivisionByZeroError
     |      gmpyError
     |      builtins.ZeroDivisionError
     |      builtins.ArithmeticError
     |      builtins.Exception
     |      builtins.BaseException
     |      builtins.object
     |  
     |  Data descriptors inherited from gmpyError:
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.ZeroDivisionError:
     |  
     |  __init__(self, /, *args, **kwargs)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  __new__(*args, **kwargs) from builtins.type
     |      Create and return a new object.  See help(type) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.BaseException:
     |  
     |  __delattr__(self, name, /)
     |      Implement delattr(self, name).
     |  
     |  __getattribute__(self, name, /)
     |      Return getattr(self, name).
     |  
     |  __reduce__(...)
     |      helper for pickle
     |  
     |  __repr__(self, /)
     |      Return repr(self).
     |  
     |  __setattr__(self, name, value, /)
     |      Implement setattr(self, name, value).
     |  
     |  __setstate__(...)
     |  
     |  __str__(self, /)
     |      Return str(self).
     |  
     |  with_traceback(...)
     |      Exception.with_traceback(tb) --
     |      set self.__traceback__ to tb and return self.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from builtins.BaseException:
     |  
     |  __cause__
     |      exception cause
     |  
     |  __context__
     |      exception context
     |  
     |  __dict__
     |  
     |  __suppress_context__
     |  
     |  __traceback__
     |  
     |  args
    
    class ExponentOutOfBoundsError(gmpyError)
     |  Base class for arithmetic errors.
     |  
     |  Method resolution order:
     |      ExponentOutOfBoundsError
     |      gmpyError
     |      builtins.ArithmeticError
     |      builtins.Exception
     |      builtins.BaseException
     |      builtins.object
     |  
     |  Data descriptors inherited from gmpyError:
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.ArithmeticError:
     |  
     |  __init__(self, /, *args, **kwargs)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  __new__(*args, **kwargs) from builtins.type
     |      Create and return a new object.  See help(type) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.BaseException:
     |  
     |  __delattr__(self, name, /)
     |      Implement delattr(self, name).
     |  
     |  __getattribute__(self, name, /)
     |      Return getattr(self, name).
     |  
     |  __reduce__(...)
     |      helper for pickle
     |  
     |  __repr__(self, /)
     |      Return repr(self).
     |  
     |  __setattr__(self, name, value, /)
     |      Implement setattr(self, name, value).
     |  
     |  __setstate__(...)
     |  
     |  __str__(self, /)
     |      Return str(self).
     |  
     |  with_traceback(...)
     |      Exception.with_traceback(tb) --
     |      set self.__traceback__ to tb and return self.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from builtins.BaseException:
     |  
     |  __cause__
     |      exception cause
     |  
     |  __context__
     |      exception context
     |  
     |  __dict__
     |  
     |  __suppress_context__
     |  
     |  __traceback__
     |  
     |  args
    
    class InexactResultError(gmpyError)
     |  Base class for arithmetic errors.
     |  
     |  Method resolution order:
     |      InexactResultError
     |      gmpyError
     |      builtins.ArithmeticError
     |      builtins.Exception
     |      builtins.BaseException
     |      builtins.object
     |  
     |  Data descriptors inherited from gmpyError:
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.ArithmeticError:
     |  
     |  __init__(self, /, *args, **kwargs)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  __new__(*args, **kwargs) from builtins.type
     |      Create and return a new object.  See help(type) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.BaseException:
     |  
     |  __delattr__(self, name, /)
     |      Implement delattr(self, name).
     |  
     |  __getattribute__(self, name, /)
     |      Return getattr(self, name).
     |  
     |  __reduce__(...)
     |      helper for pickle
     |  
     |  __repr__(self, /)
     |      Return repr(self).
     |  
     |  __setattr__(self, name, value, /)
     |      Implement setattr(self, name, value).
     |  
     |  __setstate__(...)
     |  
     |  __str__(self, /)
     |      Return str(self).
     |  
     |  with_traceback(...)
     |      Exception.with_traceback(tb) --
     |      set self.__traceback__ to tb and return self.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from builtins.BaseException:
     |  
     |  __cause__
     |      exception cause
     |  
     |  __context__
     |      exception context
     |  
     |  __dict__
     |  
     |  __suppress_context__
     |  
     |  __traceback__
     |  
     |  args
    
    class InvalidOperationError(gmpyError, builtins.ValueError)
     |  Base class for arithmetic errors.
     |  
     |  Method resolution order:
     |      InvalidOperationError
     |      gmpyError
     |      builtins.ArithmeticError
     |      builtins.ValueError
     |      builtins.Exception
     |      builtins.BaseException
     |      builtins.object
     |  
     |  Data descriptors inherited from gmpyError:
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.ArithmeticError:
     |  
     |  __init__(self, /, *args, **kwargs)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  __new__(*args, **kwargs) from builtins.type
     |      Create and return a new object.  See help(type) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.BaseException:
     |  
     |  __delattr__(self, name, /)
     |      Implement delattr(self, name).
     |  
     |  __getattribute__(self, name, /)
     |      Return getattr(self, name).
     |  
     |  __reduce__(...)
     |      helper for pickle
     |  
     |  __repr__(self, /)
     |      Return repr(self).
     |  
     |  __setattr__(self, name, value, /)
     |      Implement setattr(self, name, value).
     |  
     |  __setstate__(...)
     |  
     |  __str__(self, /)
     |      Return str(self).
     |  
     |  with_traceback(...)
     |      Exception.with_traceback(tb) --
     |      set self.__traceback__ to tb and return self.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from builtins.BaseException:
     |  
     |  __cause__
     |      exception cause
     |  
     |  __context__
     |      exception context
     |  
     |  __dict__
     |  
     |  __suppress_context__
     |  
     |  __traceback__
     |  
     |  args
    
    class OverflowResultError(InexactResultError)
     |  Base class for arithmetic errors.
     |  
     |  Method resolution order:
     |      OverflowResultError
     |      InexactResultError
     |      gmpyError
     |      builtins.ArithmeticError
     |      builtins.Exception
     |      builtins.BaseException
     |      builtins.object
     |  
     |  Data descriptors inherited from gmpyError:
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.ArithmeticError:
     |  
     |  __init__(self, /, *args, **kwargs)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  __new__(*args, **kwargs) from builtins.type
     |      Create and return a new object.  See help(type) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.BaseException:
     |  
     |  __delattr__(self, name, /)
     |      Implement delattr(self, name).
     |  
     |  __getattribute__(self, name, /)
     |      Return getattr(self, name).
     |  
     |  __reduce__(...)
     |      helper for pickle
     |  
     |  __repr__(self, /)
     |      Return repr(self).
     |  
     |  __setattr__(self, name, value, /)
     |      Implement setattr(self, name, value).
     |  
     |  __setstate__(...)
     |  
     |  __str__(self, /)
     |      Return str(self).
     |  
     |  with_traceback(...)
     |      Exception.with_traceback(tb) --
     |      set self.__traceback__ to tb and return self.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from builtins.BaseException:
     |  
     |  __cause__
     |      exception cause
     |  
     |  __context__
     |      exception context
     |  
     |  __dict__
     |  
     |  __suppress_context__
     |  
     |  __traceback__
     |  
     |  args
    
    class RangeError(gmpyError)
     |  Base class for arithmetic errors.
     |  
     |  Method resolution order:
     |      RangeError
     |      gmpyError
     |      builtins.ArithmeticError
     |      builtins.Exception
     |      builtins.BaseException
     |      builtins.object
     |  
     |  Data descriptors inherited from gmpyError:
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.ArithmeticError:
     |  
     |  __init__(self, /, *args, **kwargs)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  __new__(*args, **kwargs) from builtins.type
     |      Create and return a new object.  See help(type) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.BaseException:
     |  
     |  __delattr__(self, name, /)
     |      Implement delattr(self, name).
     |  
     |  __getattribute__(self, name, /)
     |      Return getattr(self, name).
     |  
     |  __reduce__(...)
     |      helper for pickle
     |  
     |  __repr__(self, /)
     |      Return repr(self).
     |  
     |  __setattr__(self, name, value, /)
     |      Implement setattr(self, name, value).
     |  
     |  __setstate__(...)
     |  
     |  __str__(self, /)
     |      Return str(self).
     |  
     |  with_traceback(...)
     |      Exception.with_traceback(tb) --
     |      set self.__traceback__ to tb and return self.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from builtins.BaseException:
     |  
     |  __cause__
     |      exception cause
     |  
     |  __context__
     |      exception context
     |  
     |  __dict__
     |  
     |  __suppress_context__
     |  
     |  __traceback__
     |  
     |  args
    
    class UnderflowResultError(InexactResultError)
     |  Base class for arithmetic errors.
     |  
     |  Method resolution order:
     |      UnderflowResultError
     |      InexactResultError
     |      gmpyError
     |      builtins.ArithmeticError
     |      builtins.Exception
     |      builtins.BaseException
     |      builtins.object
     |  
     |  Data descriptors inherited from gmpyError:
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.ArithmeticError:
     |  
     |  __init__(self, /, *args, **kwargs)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  __new__(*args, **kwargs) from builtins.type
     |      Create and return a new object.  See help(type) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.BaseException:
     |  
     |  __delattr__(self, name, /)
     |      Implement delattr(self, name).
     |  
     |  __getattribute__(self, name, /)
     |      Return getattr(self, name).
     |  
     |  __reduce__(...)
     |      helper for pickle
     |  
     |  __repr__(self, /)
     |      Return repr(self).
     |  
     |  __setattr__(self, name, value, /)
     |      Implement setattr(self, name, value).
     |  
     |  __setstate__(...)
     |  
     |  __str__(self, /)
     |      Return str(self).
     |  
     |  with_traceback(...)
     |      Exception.with_traceback(tb) --
     |      set self.__traceback__ to tb and return self.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from builtins.BaseException:
     |  
     |  __cause__
     |      exception cause
     |  
     |  __context__
     |      exception context
     |  
     |  __dict__
     |  
     |  __suppress_context__
     |  
     |  __traceback__
     |  
     |  args

FUNCTIONS
    acos(...)
        acos(x) -> number
        
        Return the arc-cosine of x; x in radians.
    
    acosh(...)
        acosh(x) -> number
        
        Return the inverse hyperbolic cosine of x.
    
    add(...)
        add(x, y) -> number
        
        Return x + y.
    
    agm(...)
        agm(x, y) -> mpfr
        
        Return arithmetic-geometric mean of x and y.
    
    ai(...)
        ai(x) -> mpfr
        
        Return Airy function of x.
    
    asin(...)
        asin(x) -> number
        
        Return the arc-sine of x; x in radians.
    
    asinh(...)
        asinh(x) -> number
        
        Return the inverse hyperbolic sine of x.
    
    atan(...)
        atan(x) -> number
        
        Return the arc-tangent of x; x in radians.
    
    atan2(...)
        atan2(y, x) -> mpfr
        
        Return arc-tangent of (y/x).
    
    atanh(...)
        atanh(x) -> number
        
        Return the inverse hyperbolic tangent of x.
    
    bincoef(...)
        bincoef(x, n) -> mpz
        
        Return the binomial coefficient ('x over n'). n >= 0.
    
    bit_clear(...)
        bit_clear(x, n) -> mpz
        
        Return a copy of x with the n-th bit cleared.
    
    bit_flip(...)
        bit_flip(x, n) -> mpz
        
        Return a copy of x with the n-th bit inverted.
    
    bit_length(...)
        x.bit_length() -> int
        
        Return the number of significant bits in the radix-2
        representation of x. Note: mpz(0).bit_length() returns 0.
    
    bit_mask(...)
        bit_mask(n) -> mpz
        
        Return an 'mpz' exactly n bits in length with all bits set.
    
    bit_scan0(...)
        bit_scan0(x, n=0) -> int
        
        Return the index of the first 0-bit of x with index >= n. n >= 0.
        If there are no more 0-bits in x at or above index n (which can
        only happen for x<0, assuming an infinitely long 2's complement
        format), then None is returned.
    
    bit_scan1(...)
        bit_scan1(x, n=0) -> int
        
        Return the index of the first 1-bit of x with index >= n. n >= 0.
        If there are no more 1-bits in x at or above index n (which can
        only happen for x>=0, assuming an infinitely long 2's complement
        format), then None is returned.
    
    bit_set(...)
        bit_set(x, n) -> mpz
        
        Return a copy of x with the n-th bit set.
    
    bit_test(...)
        bit_test(x, n) -> bool
        
        Return the value of the n-th bit of x.
    
    c_div(...)
        c_div(x, y) -> quotient
        
        Return the quotient of x divided by y. The quotient is rounded
        towards +Inf (ceiling rounding). x and y must be integers.
    
    c_div_2exp(...)
        c_div_2exp(x, n) -> quotient
        
        Returns the quotient of x divided by 2**n. The quotient is rounded
        towards +Inf (ceiling rounding). x must be an integer. n must be >0.
    
    c_divmod(...)
        c_divmod(x, y) -> (quotient, remainder)
        
        Return the quotient and remainder of x divided by y. The quotient
        is rounded towards +Inf (ceiling rounding) and the remainder will
        have the opposite sign of y. x and y must be integers.
    
    c_divmod_2exp(...)
        c_divmod_2exp(x ,n) -> (quotient, remainder)
        
        Return the quotient and remainder of x divided by 2**n. The quotient
        is rounded towards +Inf (ceiling rounding) and the remainder will
        be negative. x must be an integer. n must be >0.
    
    c_mod(...)
        c_mod(x, y) -> remainder
        
        Return the remainder of x divided by y. The remainder will have
        the opposite sign of y. x and y must be integers.
    
    c_mod_2exp(...)
        c_mod_2exp(x, n) -> remainder
        
        Return the remainder of x divided by 2**n. The remainder will be
        negative. x must be an integer. n must be >0.
    
    cbrt(...)
        cbrt(x) -> mpfr
        
        Return the cube root of x.
    
    ceil(...)
        ceil(x) ->mpfr
        
        Return an 'mpfr' that is the smallest integer >= x.
    
    check_range(...)
        check_range(x) -> mpfr
        
        Return a new 'mpfr' with exponent that lies within the current range
        of emin and emax.
    
    comb(...)
        comb(x, n) -> mpz
        
        Return the number of combinations of 'x things, taking n at a
        time'. n >= 0.
    
    const_catalan(...)
        const_catalan([precision=0]) -> mpfr
        
        Return the catalan constant  using the specified precision. If no
        precision is specified, the default precision is used.
    
    const_euler(...)
        const_euler([precision=0]) -> mpfr
        
        Return the euler constant using the specified precision. If no
        precision is specified, the default precision is used.
    
    const_log2(...)
        const_log2([precision=0]) -> mpfr
        
        Return the log2 constant  using the specified precision. If no
        precision is specified, the default precision is used.
    
    const_pi(...)
        const_pi([precision=0]) -> mpfr
        
        Return the constant pi using the specified precision. If no
        precision is specified, the default precision is used.
    
    context(...)
        context() -> context manager
        
        Return a new context for controlling MPFR and MPC arithmetic. To load
        the new context, use set_context(). Options can only be specified as
        keyword arguments. 
        
            precision:      precision, in bits, of an MPFR result
            real_prec:      precision, in bits, of Re(MPC)
                              -1 implies use mpfr_prec
            imag_prec:      precision, in bits, of Im(MPC)
                              -1 implies use real_prec
            round:          rounding mode for MPFR
            real_round:     rounding mode for Re(MPC)
                              -1 implies use mpfr_round
            imag_round:     rounding mode for Im(MPC)
                              -1 implies use real_round
            e_max:          maximum allowed exponent
            e_min:          minimum allowed exponent
            subnormalize:   if True, subnormalized results can be returned
            trap_underflow: if True, raise exception for underflow
                            if False, set underflow flag
            trap_overflow:  if True, raise exception for overflow
                            if False, set overflow flag and return Inf or -Inf
            trap_inexact:   if True, raise exception for inexact result
                            if False, set inexact flag
            trap_invalid:   if True, raise exception for invalid operation
                            if False, set invalid flag and return NaN
            trap_erange:    if True, raise exception for range error
                            if False, set erange flag
            trap_divzero:   if True, raise exception for division by zero
                            if False, set divzero flag and return Inf or -Inf
            trap_expbound:  if True, raise exception when mpfr/mpc exponent
                                no longer valid in current context
                            if False, mpfr/mpc with exponent out-of-bounds
                                will be coerced to either 0 or Infinity
            allow_complex:  if True, allow mpfr functions to return mpc
                            if False, mpfr functions cannot return an mpc
    
    copy_sign(...)
        copy_sign(mpfr, mpfr) -> mpfr
        
        Return an 'mpfr' composed of the first argument with the sign of the
        second argument.
    
    cos(...)
        cos(x) -> number
        
        Return the cosine of x; x in radians.
    
    cosh(...)
        cosh(x) -> number
        
        Return the hyperbolic cosine of x.
    
    cot(...)
        cot(x) -> mpfr
        
        Return cotangent of x; x in radians.
    
    coth(...)
        coth(x) -> mpfr
        
        Return hyperbolic cotangent of x.
    
    csc(...)
        csc(x) -> mpfr
        
        Return cosecant of x; x in radians.
    
    csch(...)
        csch(x) -> mpfr
        
        Return hyperbolic cosecant of x.
    
    degrees(...)
        degrees(x) -> mpfr
        
        Convert angle x from radians to degrees.
    
    denom(...)
        denom(x) -> mpz
        
        Return the denominator of x.
    
    digamma(...)
        digamma(x) -> mpfr
        
        Return digamma of x.
    
    digits(...)
        digits(x[, base[, prec]]) -> string
        
        Return string representing x. Calls mpz.digits, mpq.digits,
        mpfr.digits, or mpc.digits as appropriate.
    
    div(...)
        div(x, y) -> number
        
        Return x / y.
    
    div_2exp(...)
        div_2exp(x, n) -> number
        
        Return 'mpfr' or 'mpc' divided by 2**n.
    
    divexact(...)
        divexact(x, y) -> mpz
        
        Return the quotient of x divided by y. Faster than standard
        division but requires the remainder is zero!
    
    divm(...)
        divm(a, b, m) -> mpz
        
        Return x such that b*x == a mod m. Raises a ZeroDivisionError
        exception if no such value x exists.
    
    eint(...)
        eint(x) -> mpfr
        
        Return exponential integral of x.
    
    erf(...)
        erf(x) -> mpfr
        
        Return error function of x.
    
    erfc(...)
        erfc(x) -> mpfr
        
        Return complementary error function of x.
    
    exp(...)
        exp(x) -> number
        
        Return the exponential of x.
    
    exp10(...)
        exp10(x) -> mpfr
        
        Return 10**x.
    
    exp2(...)
        exp2(x) -> mpfr
        
        Return 2**x.
    
    expm1(...)
        expm1(x) -> mpfr
        
        Return exponential(x) - 1.
    
    f2q(...)
        f2q(x,[err]) -> mpq
        
        Return the 'best' mpq approximating x to within relative error 'err'.
        Default is the precision of x. Uses Stern-Brocot tree to find the
        'best' approximation. An 'mpz' is returned if the the denominator
        is 1. If 'err'<0, error sought is 2.0 ** err.
    
    f_div(...)
        f_div(x, y) -> quotient
        
        Return the quotient of x divided by y. The quotient is rounded
        towards -Inf (floor rounding). x and y must be integers.
    
    f_div_2exp(...)
        f_div_2exp(x, n) -? quotient
        
        Return the quotient of x divided by 2**n. The quotient is rounded
        towards -Inf (floor rounding). x must be an integer. n must be >0.
    
    f_divmod(...)
        f_divmod(x, y) -> (quotient, remainder)
        
        Return the quotient and remainder of x divided by y. The quotient
        is rounded towards -Inf (floor rounding) and the remainder will
        have the same sign as y. x and y must be integers.
    
    f_divmod_2exp(...)
        f_divmod_2exp(x, n) -> (quotient, remainder)
        
        Return quotient and remainder after dividing x by 2**n. The quotient
        is rounded towards -Inf (floor rounding) and the remainder will be
        positive. x must be an integer. n must be >0.
    
    f_mod(...)
        f_mod(x, y) -> remainder
        
        Return the remainder of x divided by y. The remainder will have
        the same sign as y. x and y must be integers.
    
    f_mod_2exp(...)
        f_mod_2exp(x, n) -> remainder
        
        Return remainder of x divided by 2**n. The remainder will be
        positive. x must be an integer. n must be >0.
    
    fac(...)
        fac(n) -> mpz
        
        Return the exact factorial of n.
        
        See factorial(n) to get the floating-point approximation.
    
    factorial(...)
        factorial(n) -> mpfr
        
        Return the floating-point approximation to the factorial of n.
        
        See fac(n) to get the exact integer result.
    
    fib(...)
        fib(n) -> mpz
        
        Return the n-th Fibonacci number.
    
    fib2(...)
        fib2(n) -> tuple
        
        Return a 2-tuple with the (n-1)-th and n-th Fibonacci numbers.
    
    floor(...)
        floor(x) -> mpfr
        
        Return an 'mpfr' that is the smallest integer <= x.
    
    fma(...)
        fma(x, y, z) -> number
        
        Return correctly rounded result of (x * y) + z.
    
    fmod(...)
        fmod(x, y) -> mpfr
        
        Return x - n*y where n is the integer quotient of x/y, rounded to 0.
    
    fms(...)
        fms(x, y, z) -> number
        
        Return correctly rounded result of (x * y) - z.
    
    frac(...)
        frac(x) -> mpfr
        
        Return fractional part of x.
    
    frexp(...)
        frexp(x) -> (int, mpfr)
        
        Return a tuple containing the exponent and mantissa of x.
    
    from_binary(...)
        from_binary(bytes) -> gmpy2 object
        Return a Python object from a byte sequence created by
        gmpy2.to_binary().
    
    fsum(...)
        fsum(iterable) -> mpfr
        
        Return an accurate sum of the values in the iterable.
    
    gamma(...)
        gamma(x) -> mpfr
        
        Return gamma of x.
    
    gcd(...)
        gcd(a, b) -> mpz
        
        Return the greatest common divisor of integers a and b.
    
    gcdext(...)
        gcdext(a, b) - > tuple
        
        Return a 3-element tuple (g,s,t) such that
            g == gcd(a,b) and g == a*s + b*t
    
    get_cache(...)
        get_cache() -> (cache_size, object_size)
        
        Return the current cache size (number of objects) and maximum size
        per object (number of limbs) for all GMPY2 objects.
    
    get_context(...)
        get_context() -> gmpy2 context
        
        Return a reference to the current context.
    
    get_emax_max(...)
        get_emax_max() -> integer
        
        Return the maximum possible exponent that can be set for 'mpfr'.
    
    get_emin_min(...)
        get_emin_min() -> integer
        
        Return the minimum possible exponent that can be set for 'mpfr'.
    
    get_exp(...)
        get_exp(mpfr) -> integer
        
        Return the exponent of an mpfr. Returns 0 for NaN or Infinity and
        sets the erange flag and will raise an exception if trap_erange
        is set.
    
    get_max_precision(...)
        get_max_precision() -> integer
        
        Return the maximum bits of precision that can be used for calculations.
        Note: to allow extra precision for intermediate calculations, avoid
        setting precision close the maximum precision.
    
    hamdist(...)
        hamdist(x, y) -> int
        
        Return the Hamming distance (number of bit-positions where the
        bits differ) between integers x and y.
    
    hypot(...)
        hypot(y, x) -> mpfr
        
        Return square root of (x**2 + y**2).
    
    ieee(...)
        ieee(bitwidth) -> context
        
        Return a new context corresponding to a standard IEEE floating point
        format. The currently supported precisions are 32, 64, and 128 bits.
    
    inf(...)
        inf(n) -> mpfr
        
        Return an 'mpfr' initialized to Infinity with the same sign as n.
        If n is not given, +Infinity is returned.
    
    invert(...)
        invert(x, m) -> mpz
        
        Return y such that x*y == 1 (mod m). Raises ZeroDivisionError if no
        inverse exists.
    
    iroot(...)
        iroot(x,n) -> (number, boolean)
        
        Return the integer n-th root of x and boolean value that is True
        iff the root is exact. x >= 0. n > 0.
    
    iroot_rem(...)
        iroot_rem(x,n) -> (number, number)
        
        Return a 2-element tuple (y,r), such that y is the integer n-th
        root of x and x=y**n + r. x >= 0. n > 0.
    
    is_bpsw_prp(...)
        is_bpsw_prp(n) -> boolean
        
        Return True if n is a Baillie-Pomerance-Selfridge-Wagstaff probable 
        prime. A BPSW probable prime passes the is_strong_prp() test with base
        2 and the is_selfridge_prp() test.
    
    is_euler_prp(...)
        is_euler_prp(n,a) -> boolean
        
        Return True if n is an Euler (also known as Solovay-Strassen)
        probable prime to the base a.
        Assuming:
            gcd(n,a) == 1
            n is odd
        Then an Euler probable prime requires:
            a**((n-1)/2) == 1 (mod n)
    
    is_even(...)
        is_even(x) -> bool
        
        Return True if x is even, False otherwise.
    
    is_extra_strong_lucas_prp(...)
        is_extra_strong_lucas_prp(n,p) -> boolean
        
        Return True if n is an extra strong Lucas probable prime with parameters
        (p,1). Assuming:
            n is odd
            D = p*p - 4, D != 0
            gcd(n, 2*D) == 1
            n = s*(2**r) + Jacobi(D,n), s odd
        Then an extra strong Lucas probable prime requires:
            (lucasu(p,1,s) == 0 (mod n)
             and
             lucasv(p,1,s) == +/-2 (mod n))
            or
            lucasv(p,1,s*(2**t)) == 0 (mod n) for some t, 0 <= t < r
    
    is_fermat_prp(...)
        is_fermat_prp(n,a) -> boolean
        
        Return True if n is a Fermat probable prime to the base a.
        Assuming:
            gcd(n,a) == 1
        Then a Fermat probable prime requires:
            a**(n-1) == 1 (mod n)
    
    is_fibonacci_prp(...)
        is_fibonacci_prp(n,p,q) -> boolean
        
        Return True if n is an Fibonacci probable prime with parameters (p,q).
        Assuming:
            n is odd
            p > 0, q = +/-1
            p*p - 4*q != 0
        Then a Fibonacci probable prime requires:
            lucasv(p,q,n) == p (mod n).
    
    is_finite(...)
        is_finite(x) -> boolean
        
        Return True if x is an actual number (i.e. not NaN or Infinity). If x is
        an mpc, return True if both x.real and x.imag are finite.
    
    is_inf(...)
        is_inf(x) -> boolean
        
        Return True if x is +Infinity or -Infinity.
        Note: is_inf() is deprecated; please use is_infinite().
    
    is_infinite(...)
        is_infinite(x) -> boolean
        
        Return True if x is +Infinity or -Infinity. If x is an mpc, return True
        if either x.real or x.imag is infinite.
    
    is_integer(...)
        is_integer(x) -> boolean
        
        Return True if x is an integer; False otherwise.
    
    is_lessgreater(...)
        is_lessgreater(x,y) -> boolean
        
        Return True if x > y or x < y. Return False if x == y or either x
        and/or y is NaN.
    
    is_lucas_prp(...)
        is_lucas_prp(n,p,q) -> boolean
        
        Return True if n is a Lucas probable prime with parameters (p,q).
        Assuming:
            n is odd
            D = p*p - 4*q, D != 0
            gcd(n, 2*q*D) == 1
        Then a Lucas probable prime requires:
            lucasu(p,q,n - Jacobi(D,n)) == 0 (mod n)
    
    is_nan(...)
        is_nan(x) -> boolean
        
        Return True if x is NaN (Not-A-Number).
    
    is_number(...)
        is_number(x) -> boolean
        
        Return True if x is an actual number (i.e. not NaN or Infinity);
        False otherwise.
        Note: is_number() is deprecated; please use is_finite().
    
    is_odd(...)
        is_odd(x) -> bool
        
        Return True if x is odd, False otherwise.
    
    is_power(...)
        is_power(x) -> bool
        
        Return True if x is a perfect power (there exists a y and an
        n > 1, such that x=y**n), else return False.
    
    is_prime(...)
        is_prime(x[, n=25]) -> bool
        
        Return True if x is _probably_ prime, else False if x is
        definitely composite. x is checked for small divisors and up
        to n Miller-Rabin tests are performed.
    
    is_regular(...)
        is_regular(x) -> boolean
        
        Return True if x is not zero, NaN, or Infinity; False otherwise.
    
    is_selfridge_prp(...)
        is_selfridge_prp(n) -> boolean
        
        Return True if n is a Lucas probable prime with Selfidge parameters
        (p,q). The Selfridge parameters are chosen by finding the first
        element D in the sequence {5, -7, 9, -11, 13, ...} such that
        Jacobi(D,n) == -1. Then let p=1 and q = (1-D)/4. Then perform
        a Lucas probable prime test.
    
    is_signed(...)
        is_signed(x) -> boolean
        
        Return True if the sign bit of x is set.
    
    is_square(...)
        is_square(x) -> bool
        
        Returns True if x is a perfect square, else return False.
    
    is_strong_bpsw_prp(...)
        is_strong_bpsw_prp(n) -> boolean
        
        Return True if n is a strong Baillie-Pomerance-Selfridge-Wagstaff
        probable prime. A strong BPSW probable prime passes the is_strong_prp()
        test with base 2 and the is_strong_selfridge_prp() test.
    
    is_strong_lucas_prp(...)
        is_strong_lucas_prp(n,p,q) -> boolean
        
        Return True if n is a strong Lucas probable prime with parameters (p,q).
        Assuming:
            n is odd
            D = p*p - 4*q, D != 0
            gcd(n, 2*q*D) == 1
            n = s*(2**r) + Jacobi(D,n), s odd
        Then a strong Lucas probable prime requires:
            lucasu(p,q,s) == 0 (mod n)
            or
            lucasv(p,q,s*(2**t)) == 0 (mod n) for some t, 0 <= t < r
    
    is_strong_prp(...)
        is_strong_prp(n,a) -> boolean
        
        Return True if n is an strong (also known as Miller-Rabin)
        probable prime to the base a.
        Assuming:
            gcd(n,a) == 1
            n is odd
            n = s*(2**r) + 1, with s odd
        Then a strong probable prime requires one of the following is true:
            a**s == 1 (mod n)
            or
            a**(s*(2**t)) == -1 (mod n) for some t, 0 <= t < r.
    
    is_strong_selfridge_prp(...)
        is_strong_selfridge_prp(n) -> boolean
        
        Return True if n is a strong Lucas probable prime with Selfidge
        parameters (p,q). The Selfridge parameters are chosen by finding
        the first element D in the sequence {5, -7, 9, -11, 13, ...} such
        that Jacobi(D,n) == -1. Then let p=1 and q = (1-D)/4. Then perform
        a strong Lucas probable prime test.
    
    is_unordered(...)
        is_unordered(x,y) -> boolean
        
        Return True if either x and/or y is NaN.
    
    is_zero(...)
        is_zero(x) -> boolean
        
        Return True if x is zero.
    
    isqrt(...)
        isqrt(x) -> mpz
        
        Return the integer square root of an integer x. x >= 0.
    
    isqrt_rem(...)
        isqrt_rem(x) -> tuple
        
        Return a 2-element tuple (s,t) such that s=isqrt(x) and t=x-s*s.
        x >=0.
    
    j0(...)
        j0(x) -> mpfr
        
        Return first kind Bessel function of order 0 of x.
    
    j1(...)
        j1(x) -> mpfr
        
        Return first kind Bessel function of order 1 of x.
    
    jacobi(...)
        jacobi(x, y) -> mpz
        
        Return the Jacobi symbol (x|y). y must be odd and >0.
    
    jn(...)
        jn(x,n) -> mpfr
        
        Return the first kind Bessel function of order n of x.
    
    kronecker(...)
        kronecker(x, y) -> mpz
        
        Return the Kronecker-Jacobi symbol (x|y).
    
    lcm(...)
        lcm(a, b) -> mpz
        
        Return the lowest common multiple of integers a and b.
    
    legendre(...)
        legendre(x, y) -> mpz
        
        Return the Legendre symbol (x|y). y is assumed to be an odd prime.
    
    lgamma(...)
        lgamma(x) -> (mpfr, int)
        
        Return a tuple containing the logarithm of the absolute value of
        gamma(x) and the sign of gamma(x)
    
    li2(...)
        li2(x) -> mpfr
        
        Return real part of dilogarithm of x.
    
    license(...)
        license() -> string
        
        Return string giving license information.
    
    lngamma(...)
        lngamma(x) -> mpfr
        
        Return logarithm of gamma(x).
    
    local_context(...)
        local_context([context[,keywords]]) -> context manager
        
        Create a context manager object that will restore the current context
        when the 'with ...' block terminates. The temporary context for the
        'with ...' block is based on the current context if no context is
        specified. Keyword arguments are supported and will modify the
        temporary new context.
    
    log(...)
        log(x) -> number
        
        Return the natural logarithm of x.
    
    log10(...)
        log10(x) -> number
        
        Return base-10 logarithm of x.
    
    log1p(...)
        log1p(x) -> mpfr
        
        Return logarithm of (1+x).
    
    log2(...)
        log2(x) -> mpfr
        
        Return base-2 logarithm of x.
    
    lucas(...)
        lucas(n) -> mpz
        
        Return the n-th Lucas number.
    
    lucas2(...)
        lucas2(n) -> tuple
        
        Return a 2-tuple with the (n-1)-th and n-th Lucas numbers.
    
    lucasu(...)
        lucasu(p,q,k) -> mpz
        
        Return the k-th element of the Lucas U sequence defined by p,q.
        p*p - 4*q must not equal 0; k must be greater than or equal to 0.
    
    lucasu_mod(...)
        lucasu_mod(p,q,k,n) -> mpz
        
        Return the k-th element of the Lucas U sequence defined by p,q (mod n).
        p*p - 4*q must not equal 0; k must be greater than or equal to 0;
        n must be greater than 0.
    
    lucasv(...)
        lucasv(p,q,k) -> mpz
        
        Return the k-th element of the Lucas V sequence defined by p,q.
        p*p - 4*q must not equal 0; k must be greater than or equal to 0.
    
    lucasv_mod(...)
        lucasv_mod(p,q,k,n) -> mpz
        
        Return the k-th element of the Lucas V sequence defined by p,q (mod n).
        p*p - 4*q must not equal 0; k must be greater than or equal to 0;
        n must be greater than 0.
    
    max2(...)
        max2(x, y) -> mpfr
        
        Return the maximum number of x and y. This function is deprecated.
        Please use maxnum() instead.
    
    maxnum(...)
        maxnum(x, y) -> mpfr
        
        Return the maximum number of x and y. If x and y are not 'mpfr', they are
        converted to 'mpfr'. The result is rounded to match the current
        context. If only one of x or y is a number, then that number is returned.
    
    min2(...)
        min2(x, y) -> mpfr
        
        Return the minimum of x and y. This function is deprecated.
        Please use minnum() instead.
    
    minnum(...)
        minnum(x, y) -> mpfr
        
        Return the minimum of x and y. If x and y are not 'mpfr', they are
        converted to 'mpfr'. The result is rounded to match the current
        context. If only one of x or y is a number, then that number is returned.
    
    modf(...)
        modf(x) -> (mpfr, mpfr)
        
        Return a tuple containing the integer and fractional portions
        of x.
    
    mp_limbsize(...)
        mp_limbsize() -> integer
        
        Return the number of bits per limb.
    
    mp_version(...)
        mp_version() -> string
        
        Return string giving the name and version of the multiple precision
        library used.
    
    mpc(...)
        mpc() -> mpc(0.0+0.0j)
        
              If no argument is given, return mpc(0.0+0.0j).
        
        mpc(c[, precision=0]) -> mpc
        
              Return a new 'mpc' object from an existing complex number
              (either a Python complex object or another 'mpc' object). If
              the precision is not specified, then the precision is taken
              from the current context. The rounding mode is always taken
              from the current context.
        
        mpc(r[, i=0[, precision=0]]) -> mpc
        
              Return a new 'mpc' object by converting two non-complex numbers
              into the real and imaginary components of an 'mpc' object. If
              the precision is not specified, then the precision is taken from
              the current context. The rounding mode is always taken from the
              current context.
        
        mpc(s[, [precision=0[, base=10]]) -> mpc
        
              Return a new 'mpc' object by converting a string s into a complex
              number. If base is omitted, then a base-10 representation is
              assumed otherwise a base between 2 and 36 can be specified. If
              the precision is not specified, then the precision is taken from
              the current context. The rounding mode is always taken from the
              current context.
        
        Note: The precision can be specified either a single number that
              is used for both the real and imaginary components, or as a
              tuple that can specify different precisions for the real
              and imaginary components.
    
    mpc_random(...)
        mpfc_random(random_state) -> mpc
        
        Return uniformly distributed number in the unit square [0,1]x[0,1].
    
    mpc_version(...)
        mpc_version() -> string
        
        Return string giving current MPC version. Return None if MPC
        support is not available.
    
    mpfr(...)
        mpfr() -> mpfr(0.0)
        
             If no argument is given, return mpfr(0.0).
        
        mpfr(n[, precison=0]) -> mpfr
        
             Return an 'mpfr' object after converting a numeric value. If
             no precision, or a precision of 0, is specified; the precison
             is taken from the current context.
        
        mpfr(s[, precision=0[, [base=0]]) -> mpfr
        
             Return 'mpfr' object after converting a string 's' made up of
             digits in the given base, possibly with fraction-part (with
             period as a separator) and/or exponent-part (with exponent
             marker 'e' for base<=10, else '@'). If no precision, or a
             precision of 0, is specified; the precison is taken from the
             current context. The base of the string representation must
             be 0 or in the interval 2 ... 62. If the base is 0, the leading
             digits of the string are used to identify the base: 0b implies
             base=2, 0x implies base=16, otherwise base=10 is assumed.
    
    mpfr_from_old_binary(...)
        mpfr_from_old_binary(string) -> mpfr
        
        Return an 'mpfr' from a GMPY 1.x binary mpf format.
    
    mpfr_grandom(...)
        mpfr_grandom(random_state) -> (mpfr, mpfr)
        
        Return two random numbers with gaussian distribution.
    
    mpfr_random(...)
        mpfr_random(random_state) -> mpfr
        
        Return uniformly distributed number between [0,1].
    
    mpfr_version(...)
        mpfr_version() -> string
        
        Return string giving current MPFR version. Return None if MPFR
        support is not available.
    
    mpq(...)
        mpq() -> mpq(0,1)
        
             If no argument is given, return mpq(0,1).
        
        mpq(n) -> mpq
        
             Return an 'mpq' object with a numeric value n. Decimal and
             Fraction values are converted exactly.
        
        mpq(n,m) -> mpq
        
             Return an 'mpq' object with a numeric value n/m.
        
        mpq(s[, base=10]) -> mpq
        
             Return an 'mpq' object from a string s made up of digits in
             the given base. s may be made up of two numbers in the same
             base separated by a '/' character.
    
    mpq_from_old_binary(...)
        mpq_from_old_binary(string) -> mpq
        
        Return an 'mpq' from a GMPY 1.x binary format.
    
    mpz(...)
        mpz() -> mpz(0)
        
             If no argument is given, return mpz(0).
        
        mpz(n) -> mpz
        
             Return an 'mpz' object with a numeric value 'n' (truncating n
             to its integer part if it's a Fraction, 'mpq', Decimal, float
             or 'mpfr').
        
        mpz(s[, base=0]):
        
             Return an 'mpz' object from a string 's' made of digits in the
             given base.  If base=0, binary, octal, or hex Python strings
             are recognized by leading 0b, 0o, or 0x characters, otherwise
             the string is assumed to be decimal. Values for base can range
             between 2 and 62.
    
    mpz_from_old_binary(...)
        mpz_from_old_binary(string) -> mpz
        
        Return an 'mpz' from a GMPY 1.x binary format.
    
    mpz_random(...)
        mpz_random(random_state, int) -> mpz
        
        Return uniformly distributed random integer between 0 and n-1.
    
    mpz_rrandomb(...)
        mpz_rrandomb(random_state, bit_count) -> mpz
        
        Return a random integer between 0 and 2**bit_count-1 with long
        sequences of zeros and one in its binary representation.
    
    mpz_urandomb(...)
        mpz_urandomb(random_state, bit_count) -> mpz
        
        Return uniformly distributed random integer between 0 and
        2**bit_count-1.
    
    mul(...)
        mul(x, y) -> number
        
        Return x * y.
    
    mul_2exp(...)
        mul_2exp(x, n) -> number
        
        Return 'mpfr' or 'mpc' multiplied by 2**n.
    
    nan(...)
        nan() -> mpfr
        
        Return an 'mpfr' initialized to NaN (Not-A-Number).
    
    next_above(...)
        next_above(x) -> mpfr
        
        Return the next 'mpfr' from x toward +Infinity.
    
    next_below(...)
        next_below(x) -> mpfr
        
        Return the next 'mpfr' from x toward -Infinity.
    
    next_prime(...)
        next_prime(x) -> mpz
        
        Return the next _probable_ prime number > x.
    
    next_toward(...)
        next_toward(y, x) -> mpfr
        
        Return the next 'mpfr' from x in the direction of y.
    
    norm(...)
        norm(x) -> mpfr
        
        Return the norm of a complex x. The norm(x) is defined as
        x.real**2 + x.imag**2. abs(x) is the square root of norm(x).
    
    num_digits(...)
        num_digits(x[, base=10]) -> int
        
        Return length of string representing the absolute value of x in
        the given base. Values  for base can range between 2 and 62. The
        value returned may be 1 too large.
    
    numer(...)
        numer(x) -> mpz
        
        Return the numerator of x.
    
    pack(...)
        pack(lst, n) -> mpz
        
        Pack a list of integers 'lst' into a single 'mpz' by concatenating
        each integer element of 'lst' after padding to length n bits. Raises
        an error if any integer is negative or greater than n bits in
        length.
    
    phase(...)
        phase(x) -> mpfr
        
        Return the phase angle, also known as argument, of a complex x.
    
    polar(...)
        polar(x) -> (abs(x), phase(x))
        
        Return the polar coordinate form of a complex x that is in
        rectangular form.
    
    popcount(...)
        popcount(x) -> int
        
        Return the number of 1-bits set in x. If x<0, the number of
        1-bits is infinite so -1 is returned in that case.
    
    powmod(...)
        powmod(x,y,m) -> mpz
        
        Return (x**y) mod m. Same as the three argument version of Python's
        built-in pow(), but converts all three arguments to mpz.
    
    proj(...)
        proj(x) -> mpc
        
        Returns the projection of a complex x on to the Riemann sphere.
    
    qdiv(...)
        qdiv(x[, y=1]) -> number
        
        Return x/y as 'mpz' if possible, or as 'mpq' if x is not exactly
        divisible by y.
    
    radians(...)
        radians(x) -> mpfr
        
        Convert angle x from degrees to radians.
    
    random_state(...)
        random_state([seed]) -> object
        
        Return new object containing state information for the random number
        generator. An optional integer can be specified as the seed value.
    
    rec_sqrt(...)
        rec_sqrt(x) -> mpfr
        
        Return the reciprocal of the square root of x.
    
    rect(...)
        rect(x) -> mpc
        
        Return the polar coordinate form of a complex x that is in
        rectangular form.
    
    reldiff(...)
        reldiff(x, y) -> mpfr
        
        Return the relative difference between x and y. Result is equal to
        abs(x-y)/x.
    
    remainder(...)
        remainder(x, y) -> mpfr
        
        Return x - n*y where n is the integer quotient of x/y, rounded to
        the nearest integer and ties rounded to even.
    
    remove(...)
        remove(x, f) -> tuple
        
        Return a 2-element tuple (y,m) such that x=y*(f**m) and f does
        not divide y. Remove the factor f from x as many times as
        possible. m is the multiplicity f in x. f > 1.
    
    remquo(...)
        remquo(x, y) -> (mpfr, int)
        
        Return a tuple containing the remainder(x,y) and the low bits of the
        quotient.
    
    rint(...)
        rint(x) -> mpfr
        
        Return x rounded to the nearest integer using the current rounding
        mode.
    
    rint_ceil(...)
        rint_ceil(x) -> mpfr
        
        Return x rounded to the nearest integer by first rounding to the
        next higher or equal integer and then, if needed, using the current
        rounding mode.
    
    rint_floor(...)
        rint_floor(x) -> mpfr
        
        Return x rounded to the nearest integer by first rounding to the
        next lower or equal integer and then, if needed, using the current
        rounding mode.
    
    rint_round(...)
        rint_round(x) -> mpfr
        
        Return x rounded to the nearest integer by first rounding to the
        nearest integer (ties away from 0) and then, if needed, using
        the current rounding mode.
    
    rint_trunc(...)
        rint_trunc(x) -> mpfr
        
        Return x rounded to the nearest integer by first rounding towards
        zero and then, if needed, using the current rounding mode.
    
    root(...)
        root(x, n) -> mpfr
        
        Return n-th root of x. The result always an 'mpfr'.
    
    round2(...)
        round2(x[, n]) -> mpfr
        
        Return x rounded to n bits. Uses default precision if n is not
        specified. See round_away() to access the mpfr_round() function.
    
    round_away(...)
        round_away(x) -> mpfr
        
        Return an 'mpfr' that is x rounded to the nearest integer,
        with ties rounded away from 0.
    
    sec(...)
        sec(x) -> mpfr
        
        Return secant of x; x in radians.
    
    sech(...)
        sech(x) -> mpfr
        
        Returns hyperbolic secant of x.
    
    set_cache(...)
        set_cache(cache_size, object_size)
        
        Set the current cache size (number of objects) and the maximum size
        per object (number of limbs). Raises ValueError if cache size exceeds
        1000 or object size exceeds 16384.
    
    set_context(...)
        set_context(context)
        
        Activate a context object controlling MPFR and MPC arithmetic.
    
    set_exp(...)
        set_exp(mpfr, n) -> mpfr
        
        Set the exponent of an mpfr to n. If n is outside the range of
        valid exponents, set_exp() will set the erange flag and either
        return the original value or raise an exception if trap_erange
        is set.
    
    set_sign(...)
        set_sign(mpfr, bool) -> mpfr
        
        If 'bool' is True, then return an 'mpfr' with the sign bit set.
    
    sign(...)
        sign(x) -> number
        
        Return -1 if x < 0, 0 if x == 0, or +1 if x >0.
    
    sin(...)
        sin(x) -> number
        
        Return the sine of x; x in radians.
    
    sin_cos(...)
        sin_cos(x) -> (number, number)
        
        Return a tuple containing the sine and cosine of x; x in radians.
    
    sinh(...)
        sinh(x) -> number
        
        Return the hyberbolic sine of x.
    
    sinh_cosh(...)
        sinh_cosh(x) -> (mpfr, mpfr)
        
        Return a tuple containing the hyperbolic sine and cosine of x.
    
    sqrt(...)
        sqrt(x) -> number
        
        Return the square root of x. If x is integer, rational, or real,
        then an 'mpfr' will be returned. If x is complex, then an 'mpc' will
        be returned. If context.allow_complex is True, negative values of x
        will return an 'mpc'.
    
    square(...)
        square(x) -> number
        
        Return x * x. If x is an integer, then the result is an 'mpz'.
        If x is a rational, then the result is an 'mpq'. If x is a float,
        then the result is an 'mpf'. If x is a complex number, then the
        result is an 'mpc'.
    
    sub(...)
        sub(x, y) -> number
        
        Return x - y.
    
    t_div(...)
        t_div(x, y) -> quotient
        
        Return the quotient of x divided by y. The quotient is rounded
        towards 0. x and y must be integers.
    
    t_div_2exp(...)
        t_div_2exp(x, n) -> quotient
        
        Return the quotient of x divided by 2**n. The quotient is rounded
        towards zero (truncation). n must be >0.
    
    t_divmod(...)
        t_divmod(x, y) -> (quotient, remainder)
        
        Return the quotient and remainder of x divided by y. The quotient
        is rounded towards zero (truncation) and the remainder will have
        the same sign as x. x and y must be integers.
    
    t_divmod_2exp(...)
        t_divmod_2exp(x, n) -> (quotient, remaidner)
        
        Return the quotient and remainder of x divided by 2**n. The quotient
        is rounded towards zero (truncation) and the remainder will have the
        same sign as x. x must be an integer. n must be >0.
    
    t_mod(...)
        t_mod(x, y) -> remainder
        
        Return the remainder of x divided by y. The remainder will have
        the same sign as x. x and y must be integers.
    
    t_mod_2exp(...)
        t_mod_2exp(x, n) -> remainder
        
        Return the remainder of x divided by 2**n. The remainder will have
        the same sign as x. x must be an integer. n must be >0.
    
    tan(...)
        tan(x) -> number
        
        Return the tangent of x; x in radians.
    
    tanh(...)
        tanh(x) -> number
        
        Return the hyperbolic tangent of x.
    
    to_binary(...)
        to_binary(x) -> bytes
        Return a Python byte sequence that is a portable binary
        representation of a gmpy2 object x. The byte sequence can
        be passed to gmpy2.from_binary() to obtain an exact copy of
        x's value. Works with mpz, xmpz, mpq, mpfr, and mpc types. 
        Raises TypeError if x is not a gmpy2 object.
    
    trunc(...)
        trunc(x) -> mpfr
        
        Return an 'mpfr' that is x truncated towards 0. Same as
        x.floor() if x>=0 or x.ceil() if x<0.
    
    unpack(...)
        unpack(x, n) -> list
        
        Unpack an integer 'x' into a list of n-bit values. Equivalent to
        repeated division by 2**n. Raises error if 'x' is negative.
    
    version(...)
        version() -> string
        
        Return string giving current GMPY2 version.
    
    xbit_mask(...)
        xbit_mask(n) -> xmpz
        
        Return an 'xmpz' exactly n bits in length with all bits set.
    
    xmpz(...)
        xmpz() -> xmpz(0)
        
             If no argument is given, return xmpz(0).
        
        xmpz(n) -> xmpz
        
             Return an 'xmpz' object with a numeric value 'n' (truncating n
             to its integer part if it's a Fraction, 'mpq', Decimal, float
             or 'mpfr').
        
        xmpz(s[, base=0]):
        
             Return an 'xmpz' object from a string 's' made of digits in the
             given base.  If base=0, binary, octal, or hex Python strings
             are recognized by leading 0b, 0o, or 0x characters, otherwise
             the string is assumed to be decimal. Values for base can range
             between 2 and 62.
        
             Note: 'xmpz' is a mutable integer. It can be faster for when
             used for augmented assignment (+=, *=, etc.). 'xmpz' objects
             cannot be used as dictionary keys. The use of 'mpz' objects is
             recommended in most cases.
    
    y0(...)
        y0(x) -> mpfr
        
        Return second kind Bessel function of order 0 of x.
    
    y1(...)
        y1(x) -> mpfr
        
        Return second kind Bessel function of order 1 of x.
    
    yn(...)
        yn(x,n) -> mpfr
        
        Return the second kind Bessel function of order n of x.
    
    zero(...)
        zero(n) -> mpfr
        
        Return an 'mpfr' inialized to 0.0 with the same sign as n.
        If n is not given, +0.0 is returned.
    
    zeta(...)
        zeta(x) -> mpfr
        
        Return Riemann zeta of x.

DATA
    Default = -1
    RoundAwayZero = 4
    RoundDown = 3
    RoundToNearest = 0
    RoundToZero = 1
    RoundUp = 2

FILE
    /Users/jack/miniconda2/envs/py37/lib/python3.6/site-packages/gmpy2.cpython-36m-darwin.so


