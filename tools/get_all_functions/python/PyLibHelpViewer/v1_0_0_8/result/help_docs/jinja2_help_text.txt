Help on package jinja2:

NAME
    jinja2

DESCRIPTION
    jinja2
    ~~~~~~
    
    Jinja2 is a template engine written in pure Python.  It provides a
    Django inspired non-XML syntax but supports inline expressions and
    an optional sandboxed environment.
    
    Nutshell
    --------
    
    Here a small example of a Jinja2 template::
    
        {% extends 'base.html' %}
        {% block title %}Memberlist{% endblock %}
        {% block content %}
          <ul>
          {% for user in users %}
            <li><a href="{{ user.url }}">{{ user.username }}</a></li>
          {% endfor %}
          </ul>
        {% endblock %}
    
    
    :copyright: (c) 2017 by the Jinja Team.
    :license: BSD, see LICENSE for more details.

PACKAGE CONTENTS
    _compat
    _identifier
    asyncfilters
    asyncsupport
    bccache
    compiler
    constants
    debug
    defaults
    environment
    exceptions
    ext
    filters
    idtracking
    lexer
    loaders
    meta
    nativetypes
    nodes
    optimizer
    parser
    runtime
    sandbox
    tests
    utils
    visitor

CLASSES
    builtins.Exception(builtins.BaseException)
        jinja2.exceptions.TemplateError
            jinja2.exceptions.TemplateNotFound(builtins.OSError, builtins.LookupError, jinja2.exceptions.TemplateError)
                jinja2.exceptions.TemplatesNotFound
            jinja2.exceptions.TemplateRuntimeError
                jinja2.exceptions.UndefinedError
            jinja2.exceptions.TemplateSyntaxError
                jinja2.exceptions.TemplateAssertionError
    builtins.LookupError(builtins.Exception)
        jinja2.exceptions.TemplateNotFound(builtins.OSError, builtins.LookupError, jinja2.exceptions.TemplateError)
            jinja2.exceptions.TemplatesNotFound
    builtins.OSError(builtins.Exception)
        jinja2.exceptions.TemplateNotFound(builtins.OSError, builtins.LookupError, jinja2.exceptions.TemplateError)
            jinja2.exceptions.TemplatesNotFound
    builtins.object
        jinja2.bccache.BytecodeCache
            jinja2.bccache.FileSystemBytecodeCache
            jinja2.bccache.MemcachedBytecodeCache
        jinja2.environment.Environment
        jinja2.environment.Template
        jinja2.loaders.BaseLoader
            jinja2.loaders.ChoiceLoader
            jinja2.loaders.DictLoader
            jinja2.loaders.FileSystemLoader
            jinja2.loaders.FunctionLoader
            jinja2.loaders.ModuleLoader
            jinja2.loaders.PackageLoader
            jinja2.loaders.PrefixLoader
        jinja2.runtime.Undefined
            jinja2.runtime.DebugUndefined
            jinja2.runtime.StrictUndefined
    builtins.str(builtins.object)
        markupsafe.Markup
    
    class BaseLoader(builtins.object)
     |  Baseclass for all loaders.  Subclass this and override `get_source` to
     |  implement a custom loading mechanism.  The environment provides a
     |  `get_template` method that calls the loader's `load` method to get the
     |  :class:`Template` object.
     |  
     |  A very basic example for a loader that looks up templates on the file
     |  system could look like this::
     |  
     |      from jinja2 import BaseLoader, TemplateNotFound
     |      from os.path import join, exists, getmtime
     |  
     |      class MyLoader(BaseLoader):
     |  
     |          def __init__(self, path):
     |              self.path = path
     |  
     |          def get_source(self, environment, template):
     |              path = join(self.path, template)
     |              if not exists(path):
     |                  raise TemplateNotFound(template)
     |              mtime = getmtime(path)
     |              with file(path) as f:
     |                  source = f.read().decode('utf-8')
     |              return source, path, lambda: mtime == getmtime(path)
     |  
     |  Methods defined here:
     |  
     |  get_source(self, environment, template)
     |      Get the template source, filename and reload helper for a template.
     |      It's passed the environment and template name and has to return a
     |      tuple in the form ``(source, filename, uptodate)`` or raise a
     |      `TemplateNotFound` error if it can't locate the template.
     |      
     |      The source part of the returned tuple must be the source of the
     |      template as unicode string or a ASCII bytestring.  The filename should
     |      be the name of the file on the filesystem if it was loaded from there,
     |      otherwise `None`.  The filename is used by python for the tracebacks
     |      if no loader extension is used.
     |      
     |      The last item in the tuple is the `uptodate` function.  If auto
     |      reloading is enabled it's always called to check if the template
     |      changed.  No arguments are passed so the function must store the
     |      old state somewhere (for example in a closure).  If it returns `False`
     |      the template will be reloaded.
     |  
     |  list_templates(self)
     |      Iterates over all templates.  If the loader does not support that
     |      it should raise a :exc:`TypeError` which is the default behavior.
     |  
     |  load(self, environment, name, globals=None)
     |      Loads a template.  This method looks up the template in the cache
     |      or loads one by calling :meth:`get_source`.  Subclasses should not
     |      override this method as loaders working on collections of other
     |      loaders (such as :class:`PrefixLoader` or :class:`ChoiceLoader`)
     |      will not call this method but `get_source` directly.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  has_source_access = True
    
    class BytecodeCache(builtins.object)
     |  To implement your own bytecode cache you have to subclass this class
     |  and override :meth:`load_bytecode` and :meth:`dump_bytecode`.  Both of
     |  these methods are passed a :class:`~jinja2.bccache.Bucket`.
     |  
     |  A very basic bytecode cache that saves the bytecode on the file system::
     |  
     |      from os import path
     |  
     |      class MyCache(BytecodeCache):
     |  
     |          def __init__(self, directory):
     |              self.directory = directory
     |  
     |          def load_bytecode(self, bucket):
     |              filename = path.join(self.directory, bucket.key)
     |              if path.exists(filename):
     |                  with open(filename, 'rb') as f:
     |                      bucket.load_bytecode(f)
     |  
     |          def dump_bytecode(self, bucket):
     |              filename = path.join(self.directory, bucket.key)
     |              with open(filename, 'wb') as f:
     |                  bucket.write_bytecode(f)
     |  
     |  A more advanced version of a filesystem based bytecode cache is part of
     |  Jinja2.
     |  
     |  Methods defined here:
     |  
     |  clear(self)
     |      Clears the cache.  This method is not used by Jinja2 but should be
     |      implemented to allow applications to clear the bytecode cache used
     |      by a particular environment.
     |  
     |  dump_bytecode(self, bucket)
     |      Subclasses have to override this method to write the bytecode
     |      from a bucket back to the cache.  If it unable to do so it must not
     |      fail silently but raise an exception.
     |  
     |  get_bucket(self, environment, name, filename, source)
     |      Return a cache bucket for the given template.  All arguments are
     |      mandatory but filename may be `None`.
     |  
     |  get_cache_key(self, name, filename=None)
     |      Returns the unique hash key for this template name.
     |  
     |  get_source_checksum(self, source)
     |      Returns a checksum for the source.
     |  
     |  load_bytecode(self, bucket)
     |      Subclasses have to override this method to load bytecode into a
     |      bucket.  If they are not able to find code in the cache for the
     |      bucket, it must not do anything.
     |  
     |  set_bucket(self, bucket)
     |      Put the bucket into the cache.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class ChoiceLoader(BaseLoader)
     |  This loader works like the `PrefixLoader` just that no prefix is
     |  specified.  If a template could not be found by one loader the next one
     |  is tried.
     |  
     |  >>> loader = ChoiceLoader([
     |  ...     FileSystemLoader('/path/to/user/templates'),
     |  ...     FileSystemLoader('/path/to/system/templates')
     |  ... ])
     |  
     |  This is useful if you want to allow users to override builtin templates
     |  from a different location.
     |  
     |  Method resolution order:
     |      ChoiceLoader
     |      BaseLoader
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, loaders)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  get_source(self, environment, template)
     |      Get the template source, filename and reload helper for a template.
     |      It's passed the environment and template name and has to return a
     |      tuple in the form ``(source, filename, uptodate)`` or raise a
     |      `TemplateNotFound` error if it can't locate the template.
     |      
     |      The source part of the returned tuple must be the source of the
     |      template as unicode string or a ASCII bytestring.  The filename should
     |      be the name of the file on the filesystem if it was loaded from there,
     |      otherwise `None`.  The filename is used by python for the tracebacks
     |      if no loader extension is used.
     |      
     |      The last item in the tuple is the `uptodate` function.  If auto
     |      reloading is enabled it's always called to check if the template
     |      changed.  No arguments are passed so the function must store the
     |      old state somewhere (for example in a closure).  If it returns `False`
     |      the template will be reloaded.
     |  
     |  list_templates(self)
     |      Iterates over all templates.  If the loader does not support that
     |      it should raise a :exc:`TypeError` which is the default behavior.
     |  
     |  load(self, environment, name, globals=None)
     |      Loads a template.  This method looks up the template in the cache
     |      or loads one by calling :meth:`get_source`.  Subclasses should not
     |      override this method as loaders working on collections of other
     |      loaders (such as :class:`PrefixLoader` or :class:`ChoiceLoader`)
     |      will not call this method but `get_source` directly.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from BaseLoader:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from BaseLoader:
     |  
     |  has_source_access = True
    
    class DebugUndefined(Undefined)
     |  An undefined that returns the debug info when printed.
     |  
     |  >>> foo = DebugUndefined(name='foo')
     |  >>> str(foo)
     |  '{{ foo }}'
     |  >>> not foo
     |  True
     |  >>> foo + 42
     |  Traceback (most recent call last):
     |    ...
     |  jinja2.exceptions.UndefinedError: 'foo' is undefined
     |  
     |  Method resolution order:
     |      DebugUndefined
     |      Undefined
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __str__(self)
     |      Return str(self).
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Undefined:
     |  
     |  __add__ = _fail_with_undefined_error(self, *args, **kwargs)
     |  
     |  __bool__ = __nonzero__(self)
     |  
     |  __call__ = _fail_with_undefined_error(self, *args, **kwargs)
     |  
     |  __complex__ = _fail_with_undefined_error(self, *args, **kwargs)
     |  
     |  __div__ = _fail_with_undefined_error(self, *args, **kwargs)
     |  
     |  __eq__(self, other)
     |      Return self==value.
     |  
     |  __float__ = _fail_with_undefined_error(self, *args, **kwargs)
     |  
     |  __floordiv__ = _fail_with_undefined_error(self, *args, **kwargs)
     |  
     |  __ge__ = _fail_with_undefined_error(self, *args, **kwargs)
     |  
     |  __getattr__(self, name)
     |  
     |  __getitem__ = _fail_with_undefined_error(self, *args, **kwargs)
     |  
     |  __gt__ = _fail_with_undefined_error(self, *args, **kwargs)
     |  
     |  __hash__(self)
     |      Return hash(self).
     |  
     |  __init__(self, hint=None, obj=missing, name=None, exc=<class 'jinja2.exceptions.UndefinedError'>)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  __int__ = _fail_with_undefined_error(self, *args, **kwargs)
     |  
     |  __iter__(self)
     |  
     |  __le__ = _fail_with_undefined_error(self, *args, **kwargs)
     |  
     |  __len__(self)
     |  
     |  __lt__ = _fail_with_undefined_error(self, *args, **kwargs)
     |  
     |  __mod__ = _fail_with_undefined_error(self, *args, **kwargs)
     |  
     |  __mul__ = _fail_with_undefined_error(self, *args, **kwargs)
     |  
     |  __ne__(self, other)
     |      Return self!=value.
     |  
     |  __neg__ = _fail_with_undefined_error(self, *args, **kwargs)
     |  
     |  __nonzero__(self)
     |  
     |  __pos__ = _fail_with_undefined_error(self, *args, **kwargs)
     |  
     |  __pow__ = _fail_with_undefined_error(self, *args, **kwargs)
     |  
     |  __radd__ = _fail_with_undefined_error(self, *args, **kwargs)
     |  
     |  __rdiv__ = _fail_with_undefined_error(self, *args, **kwargs)
     |  
     |  __repr__(self)
     |      Return repr(self).
     |  
     |  __rfloordiv__ = _fail_with_undefined_error(self, *args, **kwargs)
     |  
     |  __rmod__ = _fail_with_undefined_error(self, *args, **kwargs)
     |  
     |  __rmul__ = _fail_with_undefined_error(self, *args, **kwargs)
     |  
     |  __rpow__ = _fail_with_undefined_error(self, *args, **kwargs)
     |  
     |  __rsub__ = _fail_with_undefined_error(self, *args, **kwargs)
     |  
     |  __rtruediv__ = _fail_with_undefined_error(self, *args, **kwargs)
     |  
     |  __sub__ = _fail_with_undefined_error(self, *args, **kwargs)
     |  
     |  __truediv__ = _fail_with_undefined_error(self, *args, **kwargs)
    
    class DictLoader(BaseLoader)
     |  Loads a template from a python dict.  It's passed a dict of unicode
     |  strings bound to template names.  This loader is useful for unittesting:
     |  
     |  >>> loader = DictLoader({'index.html': 'source here'})
     |  
     |  Because auto reloading is rarely useful this is disabled per default.
     |  
     |  Method resolution order:
     |      DictLoader
     |      BaseLoader
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, mapping)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  get_source(self, environment, template)
     |      Get the template source, filename and reload helper for a template.
     |      It's passed the environment and template name and has to return a
     |      tuple in the form ``(source, filename, uptodate)`` or raise a
     |      `TemplateNotFound` error if it can't locate the template.
     |      
     |      The source part of the returned tuple must be the source of the
     |      template as unicode string or a ASCII bytestring.  The filename should
     |      be the name of the file on the filesystem if it was loaded from there,
     |      otherwise `None`.  The filename is used by python for the tracebacks
     |      if no loader extension is used.
     |      
     |      The last item in the tuple is the `uptodate` function.  If auto
     |      reloading is enabled it's always called to check if the template
     |      changed.  No arguments are passed so the function must store the
     |      old state somewhere (for example in a closure).  If it returns `False`
     |      the template will be reloaded.
     |  
     |  list_templates(self)
     |      Iterates over all templates.  If the loader does not support that
     |      it should raise a :exc:`TypeError` which is the default behavior.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from BaseLoader:
     |  
     |  load(self, environment, name, globals=None)
     |      Loads a template.  This method looks up the template in the cache
     |      or loads one by calling :meth:`get_source`.  Subclasses should not
     |      override this method as loaders working on collections of other
     |      loaders (such as :class:`PrefixLoader` or :class:`ChoiceLoader`)
     |      will not call this method but `get_source` directly.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from BaseLoader:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from BaseLoader:
     |  
     |  has_source_access = True
    
    class Environment(builtins.object)
     |  The core component of Jinja is the `Environment`.  It contains
     |  important shared variables like configuration, filters, tests,
     |  globals and others.  Instances of this class may be modified if
     |  they are not shared and if no template was loaded so far.
     |  Modifications on environments after the first template was loaded
     |  will lead to surprising effects and undefined behavior.
     |  
     |  Here are the possible initialization parameters:
     |  
     |      `block_start_string`
     |          The string marking the beginning of a block.  Defaults to ``'{%'``.
     |  
     |      `block_end_string`
     |          The string marking the end of a block.  Defaults to ``'%}'``.
     |  
     |      `variable_start_string`
     |          The string marking the beginning of a print statement.
     |          Defaults to ``'{{'``.
     |  
     |      `variable_end_string`
     |          The string marking the end of a print statement.  Defaults to
     |          ``'}}'``.
     |  
     |      `comment_start_string`
     |          The string marking the beginning of a comment.  Defaults to ``'{#'``.
     |  
     |      `comment_end_string`
     |          The string marking the end of a comment.  Defaults to ``'#}'``.
     |  
     |      `line_statement_prefix`
     |          If given and a string, this will be used as prefix for line based
     |          statements.  See also :ref:`line-statements`.
     |  
     |      `line_comment_prefix`
     |          If given and a string, this will be used as prefix for line based
     |          comments.  See also :ref:`line-statements`.
     |  
     |          .. versionadded:: 2.2
     |  
     |      `trim_blocks`
     |          If this is set to ``True`` the first newline after a block is
     |          removed (block, not variable tag!).  Defaults to `False`.
     |  
     |      `lstrip_blocks`
     |          If this is set to ``True`` leading spaces and tabs are stripped
     |          from the start of a line to a block.  Defaults to `False`.
     |  
     |      `newline_sequence`
     |          The sequence that starts a newline.  Must be one of ``'\r'``,
     |          ``'\n'`` or ``'\r\n'``.  The default is ``'\n'`` which is a
     |          useful default for Linux and OS X systems as well as web
     |          applications.
     |  
     |      `keep_trailing_newline`
     |          Preserve the trailing newline when rendering templates.
     |          The default is ``False``, which causes a single newline,
     |          if present, to be stripped from the end of the template.
     |  
     |          .. versionadded:: 2.7
     |  
     |      `extensions`
     |          List of Jinja extensions to use.  This can either be import paths
     |          as strings or extension classes.  For more information have a
     |          look at :ref:`the extensions documentation <jinja-extensions>`.
     |  
     |      `optimized`
     |          should the optimizer be enabled?  Default is ``True``.
     |  
     |      `undefined`
     |          :class:`Undefined` or a subclass of it that is used to represent
     |          undefined values in the template.
     |  
     |      `finalize`
     |          A callable that can be used to process the result of a variable
     |          expression before it is output.  For example one can convert
     |          ``None`` implicitly into an empty string here.
     |  
     |      `autoescape`
     |          If set to ``True`` the XML/HTML autoescaping feature is enabled by
     |          default.  For more details about autoescaping see
     |          :class:`~jinja2.utils.Markup`.  As of Jinja 2.4 this can also
     |          be a callable that is passed the template name and has to
     |          return ``True`` or ``False`` depending on autoescape should be
     |          enabled by default.
     |  
     |          .. versionchanged:: 2.4
     |             `autoescape` can now be a function
     |  
     |      `loader`
     |          The template loader for this environment.
     |  
     |      `cache_size`
     |          The size of the cache.  Per default this is ``400`` which means
     |          that if more than 400 templates are loaded the loader will clean
     |          out the least recently used template.  If the cache size is set to
     |          ``0`` templates are recompiled all the time, if the cache size is
     |          ``-1`` the cache will not be cleaned.
     |  
     |          .. versionchanged:: 2.8
     |             The cache size was increased to 400 from a low 50.
     |  
     |      `auto_reload`
     |          Some loaders load templates from locations where the template
     |          sources may change (ie: file system or database).  If
     |          ``auto_reload`` is set to ``True`` (default) every time a template is
     |          requested the loader checks if the source changed and if yes, it
     |          will reload the template.  For higher performance it's possible to
     |          disable that.
     |  
     |      `bytecode_cache`
     |          If set to a bytecode cache object, this object will provide a
     |          cache for the internal Jinja bytecode so that templates don't
     |          have to be parsed if they were not changed.
     |  
     |          See :ref:`bytecode-cache` for more information.
     |  
     |      `enable_async`
     |          If set to true this enables async template execution which allows
     |          you to take advantage of newer Python features.  This requires
     |          Python 3.6 or later.
     |  
     |  Methods defined here:
     |  
     |  __init__(self, block_start_string='{%', block_end_string='%}', variable_start_string='{{', variable_end_string='}}', comment_start_string='{#', comment_end_string='#}', line_statement_prefix=None, line_comment_prefix=None, trim_blocks=False, lstrip_blocks=False, newline_sequence='\n', keep_trailing_newline=False, extensions=(), optimized=True, undefined=<class 'jinja2.runtime.Undefined'>, finalize=None, autoescape=False, loader=None, cache_size=400, auto_reload=True, bytecode_cache=None, enable_async=False)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  add_extension(self, extension)
     |      Adds an extension after the environment was created.
     |      
     |      .. versionadded:: 2.5
     |  
     |  call_filter(self, name, value, args=None, kwargs=None, context=None, eval_ctx=None)
     |      Invokes a filter on a value the same way the compiler does it.
     |      
     |      Note that on Python 3 this might return a coroutine in case the
     |      filter is running from an environment in async mode and the filter
     |      supports async execution.  It's your responsibility to await this
     |      if needed.
     |      
     |      .. versionadded:: 2.7
     |  
     |  call_test(self, name, value, args=None, kwargs=None)
     |      Invokes a test on a value the same way the compiler does it.
     |      
     |      .. versionadded:: 2.7
     |  
     |  compile(self, source, name=None, filename=None, raw=False, defer_init=False)
     |      Compile a node or template source code.  The `name` parameter is
     |      the load name of the template after it was joined using
     |      :meth:`join_path` if necessary, not the filename on the file system.
     |      the `filename` parameter is the estimated filename of the template on
     |      the file system.  If the template came from a database or memory this
     |      can be omitted.
     |      
     |      The return value of this method is a python code object.  If the `raw`
     |      parameter is `True` the return value will be a string with python
     |      code equivalent to the bytecode returned otherwise.  This method is
     |      mainly used internally.
     |      
     |      `defer_init` is use internally to aid the module code generator.  This
     |      causes the generated code to be able to import without the global
     |      environment variable to be set.
     |      
     |      .. versionadded:: 2.4
     |         `defer_init` parameter added.
     |  
     |  compile_expression(self, source, undefined_to_none=True)
     |      A handy helper method that returns a callable that accepts keyword
     |      arguments that appear as variables in the expression.  If called it
     |      returns the result of the expression.
     |      
     |      This is useful if applications want to use the same rules as Jinja
     |      in template "configuration files" or similar situations.
     |      
     |      Example usage:
     |      
     |      >>> env = Environment()
     |      >>> expr = env.compile_expression('foo == 42')
     |      >>> expr(foo=23)
     |      False
     |      >>> expr(foo=42)
     |      True
     |      
     |      Per default the return value is converted to `None` if the
     |      expression returns an undefined value.  This can be changed
     |      by setting `undefined_to_none` to `False`.
     |      
     |      >>> env.compile_expression('var')() is None
     |      True
     |      >>> env.compile_expression('var', undefined_to_none=False)()
     |      Undefined
     |      
     |      .. versionadded:: 2.1
     |  
     |  compile_templates(self, target, extensions=None, filter_func=None, zip='deflated', log_function=None, ignore_errors=True, py_compile=False)
     |      Finds all the templates the loader can find, compiles them
     |      and stores them in `target`.  If `zip` is `None`, instead of in a
     |      zipfile, the templates will be stored in a directory.
     |      By default a deflate zip algorithm is used. To switch to
     |      the stored algorithm, `zip` can be set to ``'stored'``.
     |      
     |      `extensions` and `filter_func` are passed to :meth:`list_templates`.
     |      Each template returned will be compiled to the target folder or
     |      zipfile.
     |      
     |      By default template compilation errors are ignored.  In case a
     |      log function is provided, errors are logged.  If you want template
     |      syntax errors to abort the compilation you can set `ignore_errors`
     |      to `False` and you will get an exception on syntax errors.
     |      
     |      If `py_compile` is set to `True` .pyc files will be written to the
     |      target instead of standard .py files.  This flag does not do anything
     |      on pypy and Python 3 where pyc files are not picked up by itself and
     |      don't give much benefit.
     |      
     |      .. versionadded:: 2.4
     |  
     |  extend(self, **attributes)
     |      Add the items to the instance of the environment if they do not exist
     |      yet.  This is used by :ref:`extensions <writing-extensions>` to register
     |      callbacks and configuration values without breaking inheritance.
     |  
     |  from_string(self, source, globals=None, template_class=None)
     |      Load a template from a string.  This parses the source given and
     |      returns a :class:`Template` object.
     |  
     |  get_or_select_template(self, template_name_or_list, parent=None, globals=None)
     |      Does a typecheck and dispatches to :meth:`select_template`
     |      if an iterable of template names is given, otherwise to
     |      :meth:`get_template`.
     |      
     |      .. versionadded:: 2.3
     |  
     |  get_template(self, name, parent=None, globals=None)
     |      Load a template from the loader.  If a loader is configured this
     |      method asks the loader for the template and returns a :class:`Template`.
     |      If the `parent` parameter is not `None`, :meth:`join_path` is called
     |      to get the real template name before loading.
     |      
     |      The `globals` parameter can be used to provide template wide globals.
     |      These variables are available in the context at render time.
     |      
     |      If the template does not exist a :exc:`TemplateNotFound` exception is
     |      raised.
     |      
     |      .. versionchanged:: 2.4
     |         If `name` is a :class:`Template` object it is returned from the
     |         function unchanged.
     |  
     |  getattr(self, obj, attribute)
     |      Get an item or attribute of an object but prefer the attribute.
     |      Unlike :meth:`getitem` the attribute *must* be a bytestring.
     |  
     |  getitem(self, obj, argument)
     |      Get an item or attribute of an object but prefer the item.
     |  
     |  handle_exception(self, exc_info=None, rendered=False, source_hint=None)
     |      Exception handling helper.  This is used internally to either raise
     |      rewritten exceptions or return a rendered traceback for the template.
     |  
     |  iter_extensions(self)
     |      Iterates over the extensions by priority.
     |  
     |  join_path(self, template, parent)
     |      Join a template with the parent.  By default all the lookups are
     |      relative to the loader root so this method returns the `template`
     |      parameter unchanged, but if the paths should be relative to the
     |      parent template, this function can be used to calculate the real
     |      template name.
     |      
     |      Subclasses may override this method and implement template path
     |      joining here.
     |  
     |  lex(self, source, name=None, filename=None)
     |      Lex the given sourcecode and return a generator that yields
     |      tokens as tuples in the form ``(lineno, token_type, value)``.
     |      This can be useful for :ref:`extension development <writing-extensions>`
     |      and debugging templates.
     |      
     |      This does not perform preprocessing.  If you want the preprocessing
     |      of the extensions to be applied you have to filter source through
     |      the :meth:`preprocess` method.
     |  
     |  list_templates(self, extensions=None, filter_func=None)
     |      Returns a list of templates for this environment.  This requires
     |      that the loader supports the loader's
     |      :meth:`~BaseLoader.list_templates` method.
     |      
     |      If there are other files in the template folder besides the
     |      actual templates, the returned list can be filtered.  There are two
     |      ways: either `extensions` is set to a list of file extensions for
     |      templates, or a `filter_func` can be provided which is a callable that
     |      is passed a template name and should return `True` if it should end up
     |      in the result list.
     |      
     |      If the loader does not support that, a :exc:`TypeError` is raised.
     |      
     |      .. versionadded:: 2.4
     |  
     |  make_globals(self, d)
     |      Return a dict for the globals.
     |  
     |  overlay(self, block_start_string=missing, block_end_string=missing, variable_start_string=missing, variable_end_string=missing, comment_start_string=missing, comment_end_string=missing, line_statement_prefix=missing, line_comment_prefix=missing, trim_blocks=missing, lstrip_blocks=missing, extensions=missing, optimized=missing, undefined=missing, finalize=missing, autoescape=missing, loader=missing, cache_size=missing, auto_reload=missing, bytecode_cache=missing)
     |      Create a new overlay environment that shares all the data with the
     |      current environment except for cache and the overridden attributes.
     |      Extensions cannot be removed for an overlayed environment.  An overlayed
     |      environment automatically gets all the extensions of the environment it
     |      is linked to plus optional extra extensions.
     |      
     |      Creating overlays should happen after the initial environment was set
     |      up completely.  Not all attributes are truly linked, some are just
     |      copied over so modifications on the original environment may not shine
     |      through.
     |  
     |  parse(self, source, name=None, filename=None)
     |      Parse the sourcecode and return the abstract syntax tree.  This
     |      tree of nodes is used by the compiler to convert the template into
     |      executable source- or bytecode.  This is useful for debugging or to
     |      extract information from templates.
     |      
     |      If you are :ref:`developing Jinja2 extensions <writing-extensions>`
     |      this gives you a good overview of the node tree generated.
     |  
     |  preprocess(self, source, name=None, filename=None)
     |      Preprocesses the source with all extensions.  This is automatically
     |      called for all parsing and compiling methods but *not* for :meth:`lex`
     |      because there you usually only want the actual source tokenized.
     |  
     |  select_template(self, names, parent=None, globals=None)
     |      Works like :meth:`get_template` but tries a number of templates
     |      before it fails.  If it cannot find any of the templates, it will
     |      raise a :exc:`TemplatesNotFound` exception.
     |      
     |      .. versionadded:: 2.3
     |      
     |      .. versionchanged:: 2.4
     |         If `names` contains a :class:`Template` object it is returned
     |         from the function unchanged.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  lexer
     |      The lexer for this environment.
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  code_generator_class = <class 'jinja2.compiler.CodeGenerator'>
     |      Walks the abstract syntax tree and call visitor functions for every
     |      node found.  The visitor functions may return values which will be
     |      forwarded by the `visit` method.
     |      
     |      Per default the visitor functions for the nodes are ``'visit_'`` +
     |      class name of the node.  So a `TryFinally` node visit function would
     |      be `visit_TryFinally`.  This behavior can be changed by overriding
     |      the `get_visitor` function.  If no visitor function exists for a node
     |      (return value `None`) the `generic_visit` visitor is used instead.
     |  
     |  context_class = <class 'jinja2.runtime.Context'>
     |      The template context holds the variables of a template.  It stores the
     |      values passed to the template and also the names the template exports.
     |      Creating instances is neither supported nor useful as it's created
     |      automatically at various stages of the template evaluation and should not
     |      be created by hand.
     |      
     |      The context is immutable.  Modifications on :attr:`parent` **must not**
     |      happen and modifications on :attr:`vars` are allowed from generated
     |      template code only.  Template filters and global functions marked as
     |      :func:`contextfunction`\s get the active context passed as first argument
     |      and are allowed to access the context read-only.
     |      
     |      The template context supports read only dict operations (`get`,
     |      `keys`, `values`, `items`, `iterkeys`, `itervalues`, `iteritems`,
     |      `__getitem__`, `__contains__`).  Additionally there is a :meth:`resolve`
     |      method that doesn't fail with a `KeyError` but returns an
     |      :class:`Undefined` object for missing variables.
     |  
     |  exception_formatter = None
     |  
     |  exception_handler = None
     |  
     |  linked_to = None
     |  
     |  overlayed = False
     |  
     |  sandboxed = False
     |  
     |  shared = False
     |  
     |  template_class = <class 'jinja2.environment.Template'>
     |      The central template object.  This class represents a compiled template
     |      and is used to evaluate it.
     |      
     |      Normally the template object is generated from an :class:`Environment` but
     |      it also has a constructor that makes it possible to create a template
     |      instance directly using the constructor.  It takes the same arguments as
     |      the environment constructor but it's not possible to specify a loader.
     |      
     |      Every template object has a few methods and members that are guaranteed
     |      to exist.  However it's important that a template object should be
     |      considered immutable.  Modifications on the object are not supported.
     |      
     |      Template objects created from the constructor rather than an environment
     |      do have an `environment` attribute that points to a temporary environment
     |      that is probably shared with other templates created with the constructor
     |      and compatible settings.
     |      
     |      >>> template = Template('Hello {{ name }}!')
     |      >>> template.render(name='John Doe') == u'Hello John Doe!'
     |      True
     |      >>> stream = template.stream(name='John Doe')
     |      >>> next(stream) == u'Hello John Doe!'
     |      True
     |      >>> next(stream)
     |      Traceback (most recent call last):
     |          ...
     |      StopIteration
    
    class FileSystemBytecodeCache(BytecodeCache)
     |  A bytecode cache that stores bytecode on the filesystem.  It accepts
     |  two arguments: The directory where the cache items are stored and a
     |  pattern string that is used to build the filename.
     |  
     |  If no directory is specified a default cache directory is selected.  On
     |  Windows the user's temp directory is used, on UNIX systems a directory
     |  is created for the user in the system temp directory.
     |  
     |  The pattern can be used to have multiple separate caches operate on the
     |  same directory.  The default pattern is ``'__jinja2_%s.cache'``.  ``%s``
     |  is replaced with the cache key.
     |  
     |  >>> bcc = FileSystemBytecodeCache('/tmp/jinja_cache', '%s.cache')
     |  
     |  This bytecode cache supports clearing of the cache using the clear method.
     |  
     |  Method resolution order:
     |      FileSystemBytecodeCache
     |      BytecodeCache
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, directory=None, pattern='__jinja2_%s.cache')
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  clear(self)
     |      Clears the cache.  This method is not used by Jinja2 but should be
     |      implemented to allow applications to clear the bytecode cache used
     |      by a particular environment.
     |  
     |  dump_bytecode(self, bucket)
     |      Subclasses have to override this method to write the bytecode
     |      from a bucket back to the cache.  If it unable to do so it must not
     |      fail silently but raise an exception.
     |  
     |  load_bytecode(self, bucket)
     |      Subclasses have to override this method to load bytecode into a
     |      bucket.  If they are not able to find code in the cache for the
     |      bucket, it must not do anything.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from BytecodeCache:
     |  
     |  get_bucket(self, environment, name, filename, source)
     |      Return a cache bucket for the given template.  All arguments are
     |      mandatory but filename may be `None`.
     |  
     |  get_cache_key(self, name, filename=None)
     |      Returns the unique hash key for this template name.
     |  
     |  get_source_checksum(self, source)
     |      Returns a checksum for the source.
     |  
     |  set_bucket(self, bucket)
     |      Put the bucket into the cache.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from BytecodeCache:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class FileSystemLoader(BaseLoader)
     |  Loads templates from the file system.  This loader can find templates
     |  in folders on the file system and is the preferred way to load them.
     |  
     |  The loader takes the path to the templates as string, or if multiple
     |  locations are wanted a list of them which is then looked up in the
     |  given order::
     |  
     |  >>> loader = FileSystemLoader('/path/to/templates')
     |  >>> loader = FileSystemLoader(['/path/to/templates', '/other/path'])
     |  
     |  Per default the template encoding is ``'utf-8'`` which can be changed
     |  by setting the `encoding` parameter to something else.
     |  
     |  To follow symbolic links, set the *followlinks* parameter to ``True``::
     |  
     |  >>> loader = FileSystemLoader('/path/to/templates', followlinks=True)
     |  
     |  .. versionchanged:: 2.8+
     |     The *followlinks* parameter was added.
     |  
     |  Method resolution order:
     |      FileSystemLoader
     |      BaseLoader
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, searchpath, encoding='utf-8', followlinks=False)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  get_source(self, environment, template)
     |      Get the template source, filename and reload helper for a template.
     |      It's passed the environment and template name and has to return a
     |      tuple in the form ``(source, filename, uptodate)`` or raise a
     |      `TemplateNotFound` error if it can't locate the template.
     |      
     |      The source part of the returned tuple must be the source of the
     |      template as unicode string or a ASCII bytestring.  The filename should
     |      be the name of the file on the filesystem if it was loaded from there,
     |      otherwise `None`.  The filename is used by python for the tracebacks
     |      if no loader extension is used.
     |      
     |      The last item in the tuple is the `uptodate` function.  If auto
     |      reloading is enabled it's always called to check if the template
     |      changed.  No arguments are passed so the function must store the
     |      old state somewhere (for example in a closure).  If it returns `False`
     |      the template will be reloaded.
     |  
     |  list_templates(self)
     |      Iterates over all templates.  If the loader does not support that
     |      it should raise a :exc:`TypeError` which is the default behavior.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from BaseLoader:
     |  
     |  load(self, environment, name, globals=None)
     |      Loads a template.  This method looks up the template in the cache
     |      or loads one by calling :meth:`get_source`.  Subclasses should not
     |      override this method as loaders working on collections of other
     |      loaders (such as :class:`PrefixLoader` or :class:`ChoiceLoader`)
     |      will not call this method but `get_source` directly.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from BaseLoader:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from BaseLoader:
     |  
     |  has_source_access = True
    
    class FunctionLoader(BaseLoader)
     |  A loader that is passed a function which does the loading.  The
     |  function receives the name of the template and has to return either
     |  an unicode string with the template source, a tuple in the form ``(source,
     |  filename, uptodatefunc)`` or `None` if the template does not exist.
     |  
     |  >>> def load_template(name):
     |  ...     if name == 'index.html':
     |  ...         return '...'
     |  ...
     |  >>> loader = FunctionLoader(load_template)
     |  
     |  The `uptodatefunc` is a function that is called if autoreload is enabled
     |  and has to return `True` if the template is still up to date.  For more
     |  details have a look at :meth:`BaseLoader.get_source` which has the same
     |  return value.
     |  
     |  Method resolution order:
     |      FunctionLoader
     |      BaseLoader
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, load_func)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  get_source(self, environment, template)
     |      Get the template source, filename and reload helper for a template.
     |      It's passed the environment and template name and has to return a
     |      tuple in the form ``(source, filename, uptodate)`` or raise a
     |      `TemplateNotFound` error if it can't locate the template.
     |      
     |      The source part of the returned tuple must be the source of the
     |      template as unicode string or a ASCII bytestring.  The filename should
     |      be the name of the file on the filesystem if it was loaded from there,
     |      otherwise `None`.  The filename is used by python for the tracebacks
     |      if no loader extension is used.
     |      
     |      The last item in the tuple is the `uptodate` function.  If auto
     |      reloading is enabled it's always called to check if the template
     |      changed.  No arguments are passed so the function must store the
     |      old state somewhere (for example in a closure).  If it returns `False`
     |      the template will be reloaded.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from BaseLoader:
     |  
     |  list_templates(self)
     |      Iterates over all templates.  If the loader does not support that
     |      it should raise a :exc:`TypeError` which is the default behavior.
     |  
     |  load(self, environment, name, globals=None)
     |      Loads a template.  This method looks up the template in the cache
     |      or loads one by calling :meth:`get_source`.  Subclasses should not
     |      override this method as loaders working on collections of other
     |      loaders (such as :class:`PrefixLoader` or :class:`ChoiceLoader`)
     |      will not call this method but `get_source` directly.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from BaseLoader:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from BaseLoader:
     |  
     |  has_source_access = True
    
    class Markup(builtins.str)
     |  Marks a string as being safe for inclusion in HTML/XML output without
     |  needing to be escaped.  This implements the `__html__` interface a couple
     |  of frameworks and web applications use.  :class:`Markup` is a direct
     |  subclass of `unicode` and provides all the methods of `unicode` just that
     |  it escapes arguments passed and always returns `Markup`.
     |  
     |  The `escape` function returns markup objects so that double escaping can't
     |  happen.
     |  
     |  The constructor of the :class:`Markup` class can be used for three
     |  different things:  When passed an unicode object it's assumed to be safe,
     |  when passed an object with an HTML representation (has an `__html__`
     |  method) that representation is used, otherwise the object passed is
     |  converted into a unicode string and then assumed to be safe:
     |  
     |  >>> Markup("Hello <em>World</em>!")
     |  Markup(u'Hello <em>World</em>!')
     |  >>> class Foo(object):
     |  ...  def __html__(self):
     |  ...   return '<a href="#">foo</a>'
     |  ...
     |  >>> Markup(Foo())
     |  Markup(u'<a href="#">foo</a>')
     |  
     |  If you want object passed being always treated as unsafe you can use the
     |  :meth:`escape` classmethod to create a :class:`Markup` object:
     |  
     |  >>> Markup.escape("Hello <em>World</em>!")
     |  Markup(u'Hello &lt;em&gt;World&lt;/em&gt;!')
     |  
     |  Operations on a markup string are markup aware which means that all
     |  arguments are passed through the :func:`escape` function:
     |  
     |  >>> em = Markup("<em>%s</em>")
     |  >>> em % "foo & bar"
     |  Markup(u'<em>foo &amp; bar</em>')
     |  >>> strong = Markup("<strong>%(text)s</strong>")
     |  >>> strong % {'text': '<blink>hacker here</blink>'}
     |  Markup(u'<strong>&lt;blink&gt;hacker here&lt;/blink&gt;</strong>')
     |  >>> Markup("<em>Hello</em> ") + "<foo>"
     |  Markup(u'<em>Hello</em> &lt;foo&gt;')
     |  
     |  Method resolution order:
     |      Markup
     |      builtins.str
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __add__(self, other)
     |      Return self+value.
     |  
     |  __getitem__(self, *args, **kwargs)
     |      Return self[key].
     |  
     |  __html__(self)
     |  
     |  __html_format__(self, format_spec)
     |  
     |  __mod__(self, arg)
     |      Return self%value.
     |  
     |  __mul__(self, num)
     |      Return self*value.
     |  
     |  __radd__(self, other)
     |  
     |  __repr__(self)
     |      Return repr(self).
     |  
     |  __rmul__ = __mul__(self, num)
     |  
     |  capitalize(self, *args, **kwargs)
     |      S.capitalize() -> str
     |      
     |      Return a capitalized version of S, i.e. make the first character
     |      have upper case and the rest lower case.
     |  
     |  center(self, *args, **kwargs)
     |      S.center(width[, fillchar]) -> str
     |      
     |      Return S centered in a string of length width. Padding is
     |      done using the specified fill character (default is a space)
     |  
     |  expandtabs(self, *args, **kwargs)
     |      S.expandtabs(tabsize=8) -> str
     |      
     |      Return a copy of S where all tab characters are expanded using spaces.
     |      If tabsize is not given, a tab size of 8 characters is assumed.
     |  
     |  format(*args, **kwargs)
     |      S.format(*args, **kwargs) -> str
     |      
     |      Return a formatted version of S, using substitutions from args and kwargs.
     |      The substitutions are identified by braces ('{' and '}').
     |  
     |  join(self, seq)
     |      S.join(iterable) -> str
     |      
     |      Return a string which is the concatenation of the strings in the
     |      iterable.  The separator between elements is S.
     |  
     |  ljust(self, *args, **kwargs)
     |      S.ljust(width[, fillchar]) -> str
     |      
     |      Return S left-justified in a Unicode string of length width. Padding is
     |      done using the specified fill character (default is a space).
     |  
     |  lower(self, *args, **kwargs)
     |      S.lower() -> str
     |      
     |      Return a copy of the string S converted to lowercase.
     |  
     |  lstrip(self, *args, **kwargs)
     |      S.lstrip([chars]) -> str
     |      
     |      Return a copy of the string S with leading whitespace removed.
     |      If chars is given and not None, remove characters in chars instead.
     |  
     |  partition(self, sep)
     |      S.partition(sep) -> (head, sep, tail)
     |      
     |      Search for the separator sep in S, and return the part before it,
     |      the separator itself, and the part after it.  If the separator is not
     |      found, return S and two empty strings.
     |  
     |  replace(self, *args, **kwargs)
     |      S.replace(old, new[, count]) -> str
     |      
     |      Return a copy of S with all occurrences of substring
     |      old replaced by new.  If the optional argument count is
     |      given, only the first count occurrences are replaced.
     |  
     |  rjust(self, *args, **kwargs)
     |      S.rjust(width[, fillchar]) -> str
     |      
     |      Return S right-justified in a string of length width. Padding is
     |      done using the specified fill character (default is a space).
     |  
     |  rpartition(self, sep)
     |      S.rpartition(sep) -> (head, sep, tail)
     |      
     |      Search for the separator sep in S, starting at the end of S, and return
     |      the part before it, the separator itself, and the part after it.  If the
     |      separator is not found, return two empty strings and S.
     |  
     |  rsplit(self, *args, **kwargs)
     |      S.rsplit(sep=None, maxsplit=-1) -> list of strings
     |      
     |      Return a list of the words in S, using sep as the
     |      delimiter string, starting at the end of the string and
     |      working to the front.  If maxsplit is given, at most maxsplit
     |      splits are done. If sep is not specified, any whitespace string
     |      is a separator.
     |  
     |  rstrip(self, *args, **kwargs)
     |      S.rstrip([chars]) -> str
     |      
     |      Return a copy of the string S with trailing whitespace removed.
     |      If chars is given and not None, remove characters in chars instead.
     |  
     |  split(self, *args, **kwargs)
     |      S.split(sep=None, maxsplit=-1) -> list of strings
     |      
     |      Return a list of the words in S, using sep as the
     |      delimiter string.  If maxsplit is given, at most maxsplit
     |      splits are done. If sep is not specified or is None, any
     |      whitespace string is a separator and empty strings are
     |      removed from the result.
     |  
     |  splitlines(self, *args, **kwargs)
     |      S.splitlines([keepends]) -> list of strings
     |      
     |      Return a list of the lines in S, breaking at line boundaries.
     |      Line breaks are not included in the resulting list unless keepends
     |      is given and true.
     |  
     |  strip(self, *args, **kwargs)
     |      S.strip([chars]) -> str
     |      
     |      Return a copy of the string S with leading and trailing
     |      whitespace removed.
     |      If chars is given and not None, remove characters in chars instead.
     |  
     |  striptags(self)
     |      Unescape markup into an text_type string and strip all tags.  This
     |      also resolves known HTML4 and XHTML entities.  Whitespace is
     |      normalized to one:
     |      
     |      >>> Markup("Main &raquo;  <em>About</em>").striptags()
     |      u'Main \xbb About'
     |  
     |  swapcase(self, *args, **kwargs)
     |      S.swapcase() -> str
     |      
     |      Return a copy of S with uppercase characters converted to lowercase
     |      and vice versa.
     |  
     |  title(self, *args, **kwargs)
     |      S.title() -> str
     |      
     |      Return a titlecased version of S, i.e. words start with title case
     |      characters, all remaining cased characters have lower case.
     |  
     |  translate(self, *args, **kwargs)
     |      S.translate(table) -> str
     |      
     |      Return a copy of the string S in which each character has been mapped
     |      through the given translation table. The table must implement
     |      lookup/indexing via __getitem__, for instance a dictionary or list,
     |      mapping Unicode ordinals to Unicode ordinals, strings, or None. If
     |      this operation raises LookupError, the character is left untouched.
     |      Characters mapped to None are deleted.
     |  
     |  unescape(self)
     |      Unescape markup again into an text_type string.  This also resolves
     |      known HTML4 and XHTML entities:
     |      
     |      >>> Markup("Main &raquo; <em>About</em>").unescape()
     |      u'Main \xbb <em>About</em>'
     |  
     |  upper(self, *args, **kwargs)
     |      S.upper() -> str
     |      
     |      Return a copy of S converted to uppercase.
     |  
     |  zfill(self, *args, **kwargs)
     |      S.zfill(width) -> str
     |      
     |      Pad a numeric string S with zeros on the left, to fill a field
     |      of the specified width. The string S is never truncated.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods defined here:
     |  
     |  escape(s) from builtins.type
     |      Escape the string.  Works like :func:`escape` with the difference
     |      that for subclasses of :class:`Markup` this function would return the
     |      correct subclass.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods defined here:
     |  
     |  __new__(cls, base='', encoding=None, errors='strict')
     |      Create and return a new object.  See help(type) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.str:
     |  
     |  __contains__(self, key, /)
     |      Return key in self.
     |  
     |  __eq__(self, value, /)
     |      Return self==value.
     |  
     |  __format__(...)
     |      S.__format__(format_spec) -> str
     |      
     |      Return a formatted version of S as described by format_spec.
     |  
     |  __ge__(self, value, /)
     |      Return self>=value.
     |  
     |  __getattribute__(self, name, /)
     |      Return getattr(self, name).
     |  
     |  __getnewargs__(...)
     |  
     |  __gt__(self, value, /)
     |      Return self>value.
     |  
     |  __hash__(self, /)
     |      Return hash(self).
     |  
     |  __iter__(self, /)
     |      Implement iter(self).
     |  
     |  __le__(self, value, /)
     |      Return self<=value.
     |  
     |  __len__(self, /)
     |      Return len(self).
     |  
     |  __lt__(self, value, /)
     |      Return self<value.
     |  
     |  __ne__(self, value, /)
     |      Return self!=value.
     |  
     |  __rmod__(self, value, /)
     |      Return value%self.
     |  
     |  __sizeof__(...)
     |      S.__sizeof__() -> size of S in memory, in bytes
     |  
     |  __str__(self, /)
     |      Return str(self).
     |  
     |  casefold(...)
     |      S.casefold() -> str
     |      
     |      Return a version of S suitable for caseless comparisons.
     |  
     |  count(...)
     |      S.count(sub[, start[, end]]) -> int
     |      
     |      Return the number of non-overlapping occurrences of substring sub in
     |      string S[start:end].  Optional arguments start and end are
     |      interpreted as in slice notation.
     |  
     |  encode(...)
     |      S.encode(encoding='utf-8', errors='strict') -> bytes
     |      
     |      Encode S using the codec registered for encoding. Default encoding
     |      is 'utf-8'. errors may be given to set a different error
     |      handling scheme. Default is 'strict' meaning that encoding errors raise
     |      a UnicodeEncodeError. Other possible values are 'ignore', 'replace' and
     |      'xmlcharrefreplace' as well as any other name registered with
     |      codecs.register_error that can handle UnicodeEncodeErrors.
     |  
     |  endswith(...)
     |      S.endswith(suffix[, start[, end]]) -> bool
     |      
     |      Return True if S ends with the specified suffix, False otherwise.
     |      With optional start, test S beginning at that position.
     |      With optional end, stop comparing S at that position.
     |      suffix can also be a tuple of strings to try.
     |  
     |  find(...)
     |      S.find(sub[, start[, end]]) -> int
     |      
     |      Return the lowest index in S where substring sub is found,
     |      such that sub is contained within S[start:end].  Optional
     |      arguments start and end are interpreted as in slice notation.
     |      
     |      Return -1 on failure.
     |  
     |  format_map(...)
     |      S.format_map(mapping) -> str
     |      
     |      Return a formatted version of S, using substitutions from mapping.
     |      The substitutions are identified by braces ('{' and '}').
     |  
     |  index(...)
     |      S.index(sub[, start[, end]]) -> int
     |      
     |      Return the lowest index in S where substring sub is found, 
     |      such that sub is contained within S[start:end].  Optional
     |      arguments start and end are interpreted as in slice notation.
     |      
     |      Raises ValueError when the substring is not found.
     |  
     |  isalnum(...)
     |      S.isalnum() -> bool
     |      
     |      Return True if all characters in S are alphanumeric
     |      and there is at least one character in S, False otherwise.
     |  
     |  isalpha(...)
     |      S.isalpha() -> bool
     |      
     |      Return True if all characters in S are alphabetic
     |      and there is at least one character in S, False otherwise.
     |  
     |  isdecimal(...)
     |      S.isdecimal() -> bool
     |      
     |      Return True if there are only decimal characters in S,
     |      False otherwise.
     |  
     |  isdigit(...)
     |      S.isdigit() -> bool
     |      
     |      Return True if all characters in S are digits
     |      and there is at least one character in S, False otherwise.
     |  
     |  isidentifier(...)
     |      S.isidentifier() -> bool
     |      
     |      Return True if S is a valid identifier according
     |      to the language definition.
     |      
     |      Use keyword.iskeyword() to test for reserved identifiers
     |      such as "def" and "class".
     |  
     |  islower(...)
     |      S.islower() -> bool
     |      
     |      Return True if all cased characters in S are lowercase and there is
     |      at least one cased character in S, False otherwise.
     |  
     |  isnumeric(...)
     |      S.isnumeric() -> bool
     |      
     |      Return True if there are only numeric characters in S,
     |      False otherwise.
     |  
     |  isprintable(...)
     |      S.isprintable() -> bool
     |      
     |      Return True if all characters in S are considered
     |      printable in repr() or S is empty, False otherwise.
     |  
     |  isspace(...)
     |      S.isspace() -> bool
     |      
     |      Return True if all characters in S are whitespace
     |      and there is at least one character in S, False otherwise.
     |  
     |  istitle(...)
     |      S.istitle() -> bool
     |      
     |      Return True if S is a titlecased string and there is at least one
     |      character in S, i.e. upper- and titlecase characters may only
     |      follow uncased characters and lowercase characters only cased ones.
     |      Return False otherwise.
     |  
     |  isupper(...)
     |      S.isupper() -> bool
     |      
     |      Return True if all cased characters in S are uppercase and there is
     |      at least one cased character in S, False otherwise.
     |  
     |  rfind(...)
     |      S.rfind(sub[, start[, end]]) -> int
     |      
     |      Return the highest index in S where substring sub is found,
     |      such that sub is contained within S[start:end].  Optional
     |      arguments start and end are interpreted as in slice notation.
     |      
     |      Return -1 on failure.
     |  
     |  rindex(...)
     |      S.rindex(sub[, start[, end]]) -> int
     |      
     |      Return the highest index in S where substring sub is found,
     |      such that sub is contained within S[start:end].  Optional
     |      arguments start and end are interpreted as in slice notation.
     |      
     |      Raises ValueError when the substring is not found.
     |  
     |  startswith(...)
     |      S.startswith(prefix[, start[, end]]) -> bool
     |      
     |      Return True if S starts with the specified prefix, False otherwise.
     |      With optional start, test S beginning at that position.
     |      With optional end, stop comparing S at that position.
     |      prefix can also be a tuple of strings to try.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from builtins.str:
     |  
     |  maketrans(x, y=None, z=None, /)
     |      Return a translation table usable for str.translate().
     |      
     |      If there is only one argument, it must be a dictionary mapping Unicode
     |      ordinals (integers) or characters to Unicode ordinals, strings or None.
     |      Character keys will be then converted to ordinals.
     |      If there are two arguments, they must be strings of equal length, and
     |      in the resulting dictionary, each character in x will be mapped to the
     |      character at the same position in y. If there is a third argument, it
     |      must be a string, whose characters will be mapped to None in the result.
    
    class MemcachedBytecodeCache(BytecodeCache)
     |  This class implements a bytecode cache that uses a memcache cache for
     |  storing the information.  It does not enforce a specific memcache library
     |  (tummy's memcache or cmemcache) but will accept any class that provides
     |  the minimal interface required.
     |  
     |  Libraries compatible with this class:
     |  
     |  -   `werkzeug <http://werkzeug.pocoo.org/>`_.contrib.cache
     |  -   `python-memcached <https://www.tummy.com/Community/software/python-memcached/>`_
     |  -   `cmemcache <http://gijsbert.org/cmemcache/>`_
     |  
     |  (Unfortunately the django cache interface is not compatible because it
     |  does not support storing binary data, only unicode.  You can however pass
     |  the underlying cache client to the bytecode cache which is available
     |  as `django.core.cache.cache._client`.)
     |  
     |  The minimal interface for the client passed to the constructor is this:
     |  
     |  .. class:: MinimalClientInterface
     |  
     |      .. method:: set(key, value[, timeout])
     |  
     |          Stores the bytecode in the cache.  `value` is a string and
     |          `timeout` the timeout of the key.  If timeout is not provided
     |          a default timeout or no timeout should be assumed, if it's
     |          provided it's an integer with the number of seconds the cache
     |          item should exist.
     |  
     |      .. method:: get(key)
     |  
     |          Returns the value for the cache key.  If the item does not
     |          exist in the cache the return value must be `None`.
     |  
     |  The other arguments to the constructor are the prefix for all keys that
     |  is added before the actual cache key and the timeout for the bytecode in
     |  the cache system.  We recommend a high (or no) timeout.
     |  
     |  This bytecode cache does not support clearing of used items in the cache.
     |  The clear method is a no-operation function.
     |  
     |  .. versionadded:: 2.7
     |     Added support for ignoring memcache errors through the
     |     `ignore_memcache_errors` parameter.
     |  
     |  Method resolution order:
     |      MemcachedBytecodeCache
     |      BytecodeCache
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, client, prefix='jinja2/bytecode/', timeout=None, ignore_memcache_errors=True)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  dump_bytecode(self, bucket)
     |      Subclasses have to override this method to write the bytecode
     |      from a bucket back to the cache.  If it unable to do so it must not
     |      fail silently but raise an exception.
     |  
     |  load_bytecode(self, bucket)
     |      Subclasses have to override this method to load bytecode into a
     |      bucket.  If they are not able to find code in the cache for the
     |      bucket, it must not do anything.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from BytecodeCache:
     |  
     |  clear(self)
     |      Clears the cache.  This method is not used by Jinja2 but should be
     |      implemented to allow applications to clear the bytecode cache used
     |      by a particular environment.
     |  
     |  get_bucket(self, environment, name, filename, source)
     |      Return a cache bucket for the given template.  All arguments are
     |      mandatory but filename may be `None`.
     |  
     |  get_cache_key(self, name, filename=None)
     |      Returns the unique hash key for this template name.
     |  
     |  get_source_checksum(self, source)
     |      Returns a checksum for the source.
     |  
     |  set_bucket(self, bucket)
     |      Put the bucket into the cache.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from BytecodeCache:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class ModuleLoader(BaseLoader)
     |  This loader loads templates from precompiled templates.
     |  
     |  Example usage:
     |  
     |  >>> loader = ChoiceLoader([
     |  ...     ModuleLoader('/path/to/compiled/templates'),
     |  ...     FileSystemLoader('/path/to/templates')
     |  ... ])
     |  
     |  Templates can be precompiled with :meth:`Environment.compile_templates`.
     |  
     |  Method resolution order:
     |      ModuleLoader
     |      BaseLoader
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, path)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  load(self, environment, name, globals=None)
     |      Loads a template.  This method looks up the template in the cache
     |      or loads one by calling :meth:`get_source`.  Subclasses should not
     |      override this method as loaders working on collections of other
     |      loaders (such as :class:`PrefixLoader` or :class:`ChoiceLoader`)
     |      will not call this method but `get_source` directly.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods defined here:
     |  
     |  get_module_filename(name)
     |  
     |  get_template_key(name)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  has_source_access = False
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from BaseLoader:
     |  
     |  get_source(self, environment, template)
     |      Get the template source, filename and reload helper for a template.
     |      It's passed the environment and template name and has to return a
     |      tuple in the form ``(source, filename, uptodate)`` or raise a
     |      `TemplateNotFound` error if it can't locate the template.
     |      
     |      The source part of the returned tuple must be the source of the
     |      template as unicode string or a ASCII bytestring.  The filename should
     |      be the name of the file on the filesystem if it was loaded from there,
     |      otherwise `None`.  The filename is used by python for the tracebacks
     |      if no loader extension is used.
     |      
     |      The last item in the tuple is the `uptodate` function.  If auto
     |      reloading is enabled it's always called to check if the template
     |      changed.  No arguments are passed so the function must store the
     |      old state somewhere (for example in a closure).  If it returns `False`
     |      the template will be reloaded.
     |  
     |  list_templates(self)
     |      Iterates over all templates.  If the loader does not support that
     |      it should raise a :exc:`TypeError` which is the default behavior.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from BaseLoader:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class PackageLoader(BaseLoader)
     |  Load templates from python eggs or packages.  It is constructed with
     |  the name of the python package and the path to the templates in that
     |  package::
     |  
     |      loader = PackageLoader('mypackage', 'views')
     |  
     |  If the package path is not given, ``'templates'`` is assumed.
     |  
     |  Per default the template encoding is ``'utf-8'`` which can be changed
     |  by setting the `encoding` parameter to something else.  Due to the nature
     |  of eggs it's only possible to reload templates if the package was loaded
     |  from the file system and not a zip file.
     |  
     |  Method resolution order:
     |      PackageLoader
     |      BaseLoader
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, package_name, package_path='templates', encoding='utf-8')
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  get_source(self, environment, template)
     |      Get the template source, filename and reload helper for a template.
     |      It's passed the environment and template name and has to return a
     |      tuple in the form ``(source, filename, uptodate)`` or raise a
     |      `TemplateNotFound` error if it can't locate the template.
     |      
     |      The source part of the returned tuple must be the source of the
     |      template as unicode string or a ASCII bytestring.  The filename should
     |      be the name of the file on the filesystem if it was loaded from there,
     |      otherwise `None`.  The filename is used by python for the tracebacks
     |      if no loader extension is used.
     |      
     |      The last item in the tuple is the `uptodate` function.  If auto
     |      reloading is enabled it's always called to check if the template
     |      changed.  No arguments are passed so the function must store the
     |      old state somewhere (for example in a closure).  If it returns `False`
     |      the template will be reloaded.
     |  
     |  list_templates(self)
     |      Iterates over all templates.  If the loader does not support that
     |      it should raise a :exc:`TypeError` which is the default behavior.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from BaseLoader:
     |  
     |  load(self, environment, name, globals=None)
     |      Loads a template.  This method looks up the template in the cache
     |      or loads one by calling :meth:`get_source`.  Subclasses should not
     |      override this method as loaders working on collections of other
     |      loaders (such as :class:`PrefixLoader` or :class:`ChoiceLoader`)
     |      will not call this method but `get_source` directly.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from BaseLoader:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from BaseLoader:
     |  
     |  has_source_access = True
    
    class PrefixLoader(BaseLoader)
     |  A loader that is passed a dict of loaders where each loader is bound
     |  to a prefix.  The prefix is delimited from the template by a slash per
     |  default, which can be changed by setting the `delimiter` argument to
     |  something else::
     |  
     |      loader = PrefixLoader({
     |          'app1':     PackageLoader('mypackage.app1'),
     |          'app2':     PackageLoader('mypackage.app2')
     |      })
     |  
     |  By loading ``'app1/index.html'`` the file from the app1 package is loaded,
     |  by loading ``'app2/index.html'`` the file from the second.
     |  
     |  Method resolution order:
     |      PrefixLoader
     |      BaseLoader
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, mapping, delimiter='/')
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  get_loader(self, template)
     |  
     |  get_source(self, environment, template)
     |      Get the template source, filename and reload helper for a template.
     |      It's passed the environment and template name and has to return a
     |      tuple in the form ``(source, filename, uptodate)`` or raise a
     |      `TemplateNotFound` error if it can't locate the template.
     |      
     |      The source part of the returned tuple must be the source of the
     |      template as unicode string or a ASCII bytestring.  The filename should
     |      be the name of the file on the filesystem if it was loaded from there,
     |      otherwise `None`.  The filename is used by python for the tracebacks
     |      if no loader extension is used.
     |      
     |      The last item in the tuple is the `uptodate` function.  If auto
     |      reloading is enabled it's always called to check if the template
     |      changed.  No arguments are passed so the function must store the
     |      old state somewhere (for example in a closure).  If it returns `False`
     |      the template will be reloaded.
     |  
     |  list_templates(self)
     |      Iterates over all templates.  If the loader does not support that
     |      it should raise a :exc:`TypeError` which is the default behavior.
     |  
     |  load(self, environment, name, globals=None)
     |      Loads a template.  This method looks up the template in the cache
     |      or loads one by calling :meth:`get_source`.  Subclasses should not
     |      override this method as loaders working on collections of other
     |      loaders (such as :class:`PrefixLoader` or :class:`ChoiceLoader`)
     |      will not call this method but `get_source` directly.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from BaseLoader:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from BaseLoader:
     |  
     |  has_source_access = True
    
    class StrictUndefined(Undefined)
     |  An undefined that barks on print and iteration as well as boolean
     |  tests and all kinds of comparisons.  In other words: you can do nothing
     |  with it except checking if it's defined using the `defined` test.
     |  
     |  >>> foo = StrictUndefined(name='foo')
     |  >>> str(foo)
     |  Traceback (most recent call last):
     |    ...
     |  jinja2.exceptions.UndefinedError: 'foo' is undefined
     |  >>> not foo
     |  Traceback (most recent call last):
     |    ...
     |  jinja2.exceptions.UndefinedError: 'foo' is undefined
     |  >>> foo + 42
     |  Traceback (most recent call last):
     |    ...
     |  jinja2.exceptions.UndefinedError: 'foo' is undefined
     |  
     |  Method resolution order:
     |      StrictUndefined
     |      Undefined
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __bool__ = _fail_with_undefined_error(self, *args, **kwargs)
     |  
     |  __eq__ = _fail_with_undefined_error(self, *args, **kwargs)
     |  
     |  __hash__ = _fail_with_undefined_error(self, *args, **kwargs)
     |  
     |  __iter__ = _fail_with_undefined_error(self, *args, **kwargs)
     |  
     |  __len__ = _fail_with_undefined_error(self, *args, **kwargs)
     |  
     |  __ne__ = _fail_with_undefined_error(self, *args, **kwargs)
     |  
     |  __nonzero__ = _fail_with_undefined_error(self, *args, **kwargs)
     |  
     |  __str__ = _fail_with_undefined_error(self, *args, **kwargs)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Undefined:
     |  
     |  __add__ = _fail_with_undefined_error(self, *args, **kwargs)
     |  
     |  __call__ = _fail_with_undefined_error(self, *args, **kwargs)
     |  
     |  __complex__ = _fail_with_undefined_error(self, *args, **kwargs)
     |  
     |  __div__ = _fail_with_undefined_error(self, *args, **kwargs)
     |  
     |  __float__ = _fail_with_undefined_error(self, *args, **kwargs)
     |  
     |  __floordiv__ = _fail_with_undefined_error(self, *args, **kwargs)
     |  
     |  __ge__ = _fail_with_undefined_error(self, *args, **kwargs)
     |  
     |  __getattr__(self, name)
     |  
     |  __getitem__ = _fail_with_undefined_error(self, *args, **kwargs)
     |  
     |  __gt__ = _fail_with_undefined_error(self, *args, **kwargs)
     |  
     |  __init__(self, hint=None, obj=missing, name=None, exc=<class 'jinja2.exceptions.UndefinedError'>)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  __int__ = _fail_with_undefined_error(self, *args, **kwargs)
     |  
     |  __le__ = _fail_with_undefined_error(self, *args, **kwargs)
     |  
     |  __lt__ = _fail_with_undefined_error(self, *args, **kwargs)
     |  
     |  __mod__ = _fail_with_undefined_error(self, *args, **kwargs)
     |  
     |  __mul__ = _fail_with_undefined_error(self, *args, **kwargs)
     |  
     |  __neg__ = _fail_with_undefined_error(self, *args, **kwargs)
     |  
     |  __pos__ = _fail_with_undefined_error(self, *args, **kwargs)
     |  
     |  __pow__ = _fail_with_undefined_error(self, *args, **kwargs)
     |  
     |  __radd__ = _fail_with_undefined_error(self, *args, **kwargs)
     |  
     |  __rdiv__ = _fail_with_undefined_error(self, *args, **kwargs)
     |  
     |  __repr__(self)
     |      Return repr(self).
     |  
     |  __rfloordiv__ = _fail_with_undefined_error(self, *args, **kwargs)
     |  
     |  __rmod__ = _fail_with_undefined_error(self, *args, **kwargs)
     |  
     |  __rmul__ = _fail_with_undefined_error(self, *args, **kwargs)
     |  
     |  __rpow__ = _fail_with_undefined_error(self, *args, **kwargs)
     |  
     |  __rsub__ = _fail_with_undefined_error(self, *args, **kwargs)
     |  
     |  __rtruediv__ = _fail_with_undefined_error(self, *args, **kwargs)
     |  
     |  __sub__ = _fail_with_undefined_error(self, *args, **kwargs)
     |  
     |  __truediv__ = _fail_with_undefined_error(self, *args, **kwargs)
    
    class Template(builtins.object)
     |  The central template object.  This class represents a compiled template
     |  and is used to evaluate it.
     |  
     |  Normally the template object is generated from an :class:`Environment` but
     |  it also has a constructor that makes it possible to create a template
     |  instance directly using the constructor.  It takes the same arguments as
     |  the environment constructor but it's not possible to specify a loader.
     |  
     |  Every template object has a few methods and members that are guaranteed
     |  to exist.  However it's important that a template object should be
     |  considered immutable.  Modifications on the object are not supported.
     |  
     |  Template objects created from the constructor rather than an environment
     |  do have an `environment` attribute that points to a temporary environment
     |  that is probably shared with other templates created with the constructor
     |  and compatible settings.
     |  
     |  >>> template = Template('Hello {{ name }}!')
     |  >>> template.render(name='John Doe') == u'Hello John Doe!'
     |  True
     |  >>> stream = template.stream(name='John Doe')
     |  >>> next(stream) == u'Hello John Doe!'
     |  True
     |  >>> next(stream)
     |  Traceback (most recent call last):
     |      ...
     |  StopIteration
     |  
     |  Methods defined here:
     |  
     |  __repr__(self)
     |      Return repr(self).
     |  
     |  generate(self, *args, **kwargs)
     |      For very large templates it can be useful to not render the whole
     |      template at once but evaluate each statement after another and yield
     |      piece for piece.  This method basically does exactly that and returns
     |      a generator that yields one item after another as unicode strings.
     |      
     |      It accepts the same arguments as :meth:`render`.
     |  
     |  generate_async(self, *args, **kwargs)
     |      An async version of :meth:`generate`.  Works very similarly but
     |      returns an async iterator instead.
     |  
     |  get_corresponding_lineno(self, lineno)
     |      Return the source line number of a line number in the
     |      generated bytecode as they are not in sync.
     |  
     |  make_module(self, vars=None, shared=False, locals=None)
     |      This method works like the :attr:`module` attribute when called
     |      without arguments but it will evaluate the template on every call
     |      rather than caching it.  It's also possible to provide
     |      a dict which is then used as context.  The arguments are the same
     |      as for the :meth:`new_context` method.
     |  
     |  make_module_async(self, vars=None, shared=False, locals=None)
     |      As template module creation can invoke template code for
     |      asynchronous exections this method must be used instead of the
     |      normal :meth:`make_module` one.  Likewise the module attribute
     |      becomes unavailable in async mode.
     |  
     |  new_context(self, vars=None, shared=False, locals=None)
     |      Create a new :class:`Context` for this template.  The vars
     |      provided will be passed to the template.  Per default the globals
     |      are added to the context.  If shared is set to `True` the data
     |      is passed as it to the context without adding the globals.
     |      
     |      `locals` can be a dict of local variables for internal usage.
     |  
     |  render(self, *args, **kwargs)
     |      This method accepts the same arguments as the `dict` constructor:
     |      A dict, a dict subclass or some keyword arguments.  If no arguments
     |      are given the context will be empty.  These two calls do the same::
     |      
     |          template.render(knights='that say nih')
     |          template.render({'knights': 'that say nih'})
     |      
     |      This will return the rendered template as unicode string.
     |  
     |  render_async(self, *args, **kwargs)
     |      This works similar to :meth:`render` but returns a coroutine
     |      that when awaited returns the entire rendered template string.  This
     |      requires the async feature to be enabled.
     |      
     |      Example usage::
     |      
     |          await template.render_async(knights='that say nih; asynchronously')
     |  
     |  stream(self, *args, **kwargs)
     |      Works exactly like :meth:`generate` but returns a
     |      :class:`TemplateStream`.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods defined here:
     |  
     |  from_code(environment, code, globals, uptodate=None) from builtins.type
     |      Creates a template object from compiled code and the globals.  This
     |      is used by the loaders and environment to create a template object.
     |  
     |  from_module_dict(environment, module_dict, globals) from builtins.type
     |      Creates a template object from a module.  This is used by the
     |      module loader to create a template object.
     |      
     |      .. versionadded:: 2.4
     |  
     |  ----------------------------------------------------------------------
     |  Static methods defined here:
     |  
     |  __new__(cls, source, block_start_string='{%', block_end_string='%}', variable_start_string='{{', variable_end_string='}}', comment_start_string='{#', comment_end_string='#}', line_statement_prefix=None, line_comment_prefix=None, trim_blocks=False, lstrip_blocks=False, newline_sequence='\n', keep_trailing_newline=False, extensions=(), optimized=True, undefined=<class 'jinja2.runtime.Undefined'>, finalize=None, autoescape=False, enable_async=False)
     |      Create and return a new object.  See help(type) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  debug_info
     |      The debug info mapping.
     |  
     |  is_up_to_date
     |      If this variable is `False` there is a newer version available.
     |  
     |  module
     |      The template as module.  This is used for imports in the
     |      template runtime but is also useful if one wants to access
     |      exported template variables from the Python layer:
     |      
     |      >>> t = Template('{% macro foo() %}42{% endmacro %}23')
     |      >>> str(t.module)
     |      '23'
     |      >>> t.module.foo() == u'42'
     |      True
     |      
     |      This attribute is not available if async mode is enabled.
    
    class TemplateAssertionError(TemplateSyntaxError)
     |  Like a template syntax error, but covers cases where something in the
     |  template caused an error at compile time that wasn't necessarily caused
     |  by a syntax error.  However it's a direct subclass of
     |  :exc:`TemplateSyntaxError` and has the same attributes.
     |  
     |  Method resolution order:
     |      TemplateAssertionError
     |      TemplateSyntaxError
     |      TemplateError
     |      builtins.Exception
     |      builtins.BaseException
     |      builtins.object
     |  
     |  Methods inherited from TemplateSyntaxError:
     |  
     |  __init__(self, message, lineno, name=None, filename=None)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  __str__(self)
     |      Return str(self).
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from TemplateError:
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  message
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.Exception:
     |  
     |  __new__(*args, **kwargs) from builtins.type
     |      Create and return a new object.  See help(type) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.BaseException:
     |  
     |  __delattr__(self, name, /)
     |      Implement delattr(self, name).
     |  
     |  __getattribute__(self, name, /)
     |      Return getattr(self, name).
     |  
     |  __reduce__(...)
     |      helper for pickle
     |  
     |  __repr__(self, /)
     |      Return repr(self).
     |  
     |  __setattr__(self, name, value, /)
     |      Implement setattr(self, name, value).
     |  
     |  __setstate__(...)
     |  
     |  with_traceback(...)
     |      Exception.with_traceback(tb) --
     |      set self.__traceback__ to tb and return self.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from builtins.BaseException:
     |  
     |  __cause__
     |      exception cause
     |  
     |  __context__
     |      exception context
     |  
     |  __dict__
     |  
     |  __suppress_context__
     |  
     |  __traceback__
     |  
     |  args
    
    class TemplateError(builtins.Exception)
     |  Baseclass for all template errors.
     |  
     |  Method resolution order:
     |      TemplateError
     |      builtins.Exception
     |      builtins.BaseException
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, message=None)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  message
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.Exception:
     |  
     |  __new__(*args, **kwargs) from builtins.type
     |      Create and return a new object.  See help(type) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.BaseException:
     |  
     |  __delattr__(self, name, /)
     |      Implement delattr(self, name).
     |  
     |  __getattribute__(self, name, /)
     |      Return getattr(self, name).
     |  
     |  __reduce__(...)
     |      helper for pickle
     |  
     |  __repr__(self, /)
     |      Return repr(self).
     |  
     |  __setattr__(self, name, value, /)
     |      Implement setattr(self, name, value).
     |  
     |  __setstate__(...)
     |  
     |  __str__(self, /)
     |      Return str(self).
     |  
     |  with_traceback(...)
     |      Exception.with_traceback(tb) --
     |      set self.__traceback__ to tb and return self.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from builtins.BaseException:
     |  
     |  __cause__
     |      exception cause
     |  
     |  __context__
     |      exception context
     |  
     |  __dict__
     |  
     |  __suppress_context__
     |  
     |  __traceback__
     |  
     |  args
    
    class TemplateNotFound(builtins.OSError, builtins.LookupError, TemplateError)
     |  Raised if a template does not exist.
     |  
     |  Method resolution order:
     |      TemplateNotFound
     |      builtins.OSError
     |      builtins.LookupError
     |      TemplateError
     |      builtins.Exception
     |      builtins.BaseException
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, name, message=None)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  __str__(self)
     |      Return str(self).
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  message = None
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.OSError:
     |  
     |  __new__(*args, **kwargs) from builtins.type
     |      Create and return a new object.  See help(type) for accurate signature.
     |  
     |  __reduce__(...)
     |      helper for pickle
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from builtins.OSError:
     |  
     |  characters_written
     |  
     |  errno
     |      POSIX exception code
     |  
     |  filename
     |      exception filename
     |  
     |  filename2
     |      second exception filename
     |  
     |  strerror
     |      exception strerror
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.BaseException:
     |  
     |  __delattr__(self, name, /)
     |      Implement delattr(self, name).
     |  
     |  __getattribute__(self, name, /)
     |      Return getattr(self, name).
     |  
     |  __repr__(self, /)
     |      Return repr(self).
     |  
     |  __setattr__(self, name, value, /)
     |      Implement setattr(self, name, value).
     |  
     |  __setstate__(...)
     |  
     |  with_traceback(...)
     |      Exception.with_traceback(tb) --
     |      set self.__traceback__ to tb and return self.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from builtins.BaseException:
     |  
     |  __cause__
     |      exception cause
     |  
     |  __context__
     |      exception context
     |  
     |  __dict__
     |  
     |  __suppress_context__
     |  
     |  __traceback__
     |  
     |  args
    
    class TemplateRuntimeError(TemplateError)
     |  A generic runtime error in the template engine.  Under some situations
     |  Jinja may raise this exception.
     |  
     |  Method resolution order:
     |      TemplateRuntimeError
     |      TemplateError
     |      builtins.Exception
     |      builtins.BaseException
     |      builtins.object
     |  
     |  Methods inherited from TemplateError:
     |  
     |  __init__(self, message=None)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from TemplateError:
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  message
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.Exception:
     |  
     |  __new__(*args, **kwargs) from builtins.type
     |      Create and return a new object.  See help(type) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.BaseException:
     |  
     |  __delattr__(self, name, /)
     |      Implement delattr(self, name).
     |  
     |  __getattribute__(self, name, /)
     |      Return getattr(self, name).
     |  
     |  __reduce__(...)
     |      helper for pickle
     |  
     |  __repr__(self, /)
     |      Return repr(self).
     |  
     |  __setattr__(self, name, value, /)
     |      Implement setattr(self, name, value).
     |  
     |  __setstate__(...)
     |  
     |  __str__(self, /)
     |      Return str(self).
     |  
     |  with_traceback(...)
     |      Exception.with_traceback(tb) --
     |      set self.__traceback__ to tb and return self.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from builtins.BaseException:
     |  
     |  __cause__
     |      exception cause
     |  
     |  __context__
     |      exception context
     |  
     |  __dict__
     |  
     |  __suppress_context__
     |  
     |  __traceback__
     |  
     |  args
    
    class TemplateSyntaxError(TemplateError)
     |  Raised to tell the user that there is a problem with the template.
     |  
     |  Method resolution order:
     |      TemplateSyntaxError
     |      TemplateError
     |      builtins.Exception
     |      builtins.BaseException
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, message, lineno, name=None, filename=None)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  __str__(self)
     |      Return str(self).
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from TemplateError:
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  message
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.Exception:
     |  
     |  __new__(*args, **kwargs) from builtins.type
     |      Create and return a new object.  See help(type) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.BaseException:
     |  
     |  __delattr__(self, name, /)
     |      Implement delattr(self, name).
     |  
     |  __getattribute__(self, name, /)
     |      Return getattr(self, name).
     |  
     |  __reduce__(...)
     |      helper for pickle
     |  
     |  __repr__(self, /)
     |      Return repr(self).
     |  
     |  __setattr__(self, name, value, /)
     |      Implement setattr(self, name, value).
     |  
     |  __setstate__(...)
     |  
     |  with_traceback(...)
     |      Exception.with_traceback(tb) --
     |      set self.__traceback__ to tb and return self.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from builtins.BaseException:
     |  
     |  __cause__
     |      exception cause
     |  
     |  __context__
     |      exception context
     |  
     |  __dict__
     |  
     |  __suppress_context__
     |  
     |  __traceback__
     |  
     |  args
    
    class TemplatesNotFound(TemplateNotFound)
     |  Like :class:`TemplateNotFound` but raised if multiple templates
     |  are selected.  This is a subclass of :class:`TemplateNotFound`
     |  exception, so just catching the base exception will catch both.
     |  
     |  .. versionadded:: 2.2
     |  
     |  Method resolution order:
     |      TemplatesNotFound
     |      TemplateNotFound
     |      builtins.OSError
     |      builtins.LookupError
     |      TemplateError
     |      builtins.Exception
     |      builtins.BaseException
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, names=(), message=None)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from TemplateNotFound:
     |  
     |  __str__(self)
     |      Return str(self).
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from TemplateNotFound:
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from TemplateNotFound:
     |  
     |  message = None
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.OSError:
     |  
     |  __new__(*args, **kwargs) from builtins.type
     |      Create and return a new object.  See help(type) for accurate signature.
     |  
     |  __reduce__(...)
     |      helper for pickle
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from builtins.OSError:
     |  
     |  characters_written
     |  
     |  errno
     |      POSIX exception code
     |  
     |  filename
     |      exception filename
     |  
     |  filename2
     |      second exception filename
     |  
     |  strerror
     |      exception strerror
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.BaseException:
     |  
     |  __delattr__(self, name, /)
     |      Implement delattr(self, name).
     |  
     |  __getattribute__(self, name, /)
     |      Return getattr(self, name).
     |  
     |  __repr__(self, /)
     |      Return repr(self).
     |  
     |  __setattr__(self, name, value, /)
     |      Implement setattr(self, name, value).
     |  
     |  __setstate__(...)
     |  
     |  with_traceback(...)
     |      Exception.with_traceback(tb) --
     |      set self.__traceback__ to tb and return self.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from builtins.BaseException:
     |  
     |  __cause__
     |      exception cause
     |  
     |  __context__
     |      exception context
     |  
     |  __dict__
     |  
     |  __suppress_context__
     |  
     |  __traceback__
     |  
     |  args
    
    class Undefined(builtins.object)
     |  The default undefined type.  This undefined type can be printed and
     |  iterated over, but every other access will raise an :exc:`jinja2.exceptions.UndefinedError`:
     |  
     |  >>> foo = Undefined(name='foo')
     |  >>> str(foo)
     |  ''
     |  >>> not foo
     |  True
     |  >>> foo + 42
     |  Traceback (most recent call last):
     |    ...
     |  jinja2.exceptions.UndefinedError: 'foo' is undefined
     |  
     |  Methods defined here:
     |  
     |  __add__ = _fail_with_undefined_error(self, *args, **kwargs)
     |  
     |  __bool__ = __nonzero__(self)
     |  
     |  __call__ = _fail_with_undefined_error(self, *args, **kwargs)
     |  
     |  __complex__ = _fail_with_undefined_error(self, *args, **kwargs)
     |  
     |  __div__ = _fail_with_undefined_error(self, *args, **kwargs)
     |  
     |  __eq__(self, other)
     |      Return self==value.
     |  
     |  __float__ = _fail_with_undefined_error(self, *args, **kwargs)
     |  
     |  __floordiv__ = _fail_with_undefined_error(self, *args, **kwargs)
     |  
     |  __ge__ = _fail_with_undefined_error(self, *args, **kwargs)
     |  
     |  __getattr__(self, name)
     |  
     |  __getitem__ = _fail_with_undefined_error(self, *args, **kwargs)
     |  
     |  __gt__ = _fail_with_undefined_error(self, *args, **kwargs)
     |  
     |  __hash__(self)
     |      Return hash(self).
     |  
     |  __init__(self, hint=None, obj=missing, name=None, exc=<class 'jinja2.exceptions.UndefinedError'>)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  __int__ = _fail_with_undefined_error(self, *args, **kwargs)
     |  
     |  __iter__(self)
     |  
     |  __le__ = _fail_with_undefined_error(self, *args, **kwargs)
     |  
     |  __len__(self)
     |  
     |  __lt__ = _fail_with_undefined_error(self, *args, **kwargs)
     |  
     |  __mod__ = _fail_with_undefined_error(self, *args, **kwargs)
     |  
     |  __mul__ = _fail_with_undefined_error(self, *args, **kwargs)
     |  
     |  __ne__(self, other)
     |      Return self!=value.
     |  
     |  __neg__ = _fail_with_undefined_error(self, *args, **kwargs)
     |  
     |  __nonzero__(self)
     |  
     |  __pos__ = _fail_with_undefined_error(self, *args, **kwargs)
     |  
     |  __pow__ = _fail_with_undefined_error(self, *args, **kwargs)
     |  
     |  __radd__ = _fail_with_undefined_error(self, *args, **kwargs)
     |  
     |  __rdiv__ = _fail_with_undefined_error(self, *args, **kwargs)
     |  
     |  __repr__(self)
     |      Return repr(self).
     |  
     |  __rfloordiv__ = _fail_with_undefined_error(self, *args, **kwargs)
     |  
     |  __rmod__ = _fail_with_undefined_error(self, *args, **kwargs)
     |  
     |  __rmul__ = _fail_with_undefined_error(self, *args, **kwargs)
     |  
     |  __rpow__ = _fail_with_undefined_error(self, *args, **kwargs)
     |  
     |  __rsub__ = _fail_with_undefined_error(self, *args, **kwargs)
     |  
     |  __rtruediv__ = _fail_with_undefined_error(self, *args, **kwargs)
     |  
     |  __str__(self)
     |      Return str(self).
     |  
     |  __sub__ = _fail_with_undefined_error(self, *args, **kwargs)
     |  
     |  __truediv__ = _fail_with_undefined_error(self, *args, **kwargs)
    
    class UndefinedError(TemplateRuntimeError)
     |  Raised if a template tries to operate on :class:`Undefined`.
     |  
     |  Method resolution order:
     |      UndefinedError
     |      TemplateRuntimeError
     |      TemplateError
     |      builtins.Exception
     |      builtins.BaseException
     |      builtins.object
     |  
     |  Methods inherited from TemplateError:
     |  
     |  __init__(self, message=None)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from TemplateError:
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  message
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.Exception:
     |  
     |  __new__(*args, **kwargs) from builtins.type
     |      Create and return a new object.  See help(type) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.BaseException:
     |  
     |  __delattr__(self, name, /)
     |      Implement delattr(self, name).
     |  
     |  __getattribute__(self, name, /)
     |      Return getattr(self, name).
     |  
     |  __reduce__(...)
     |      helper for pickle
     |  
     |  __repr__(self, /)
     |      Return repr(self).
     |  
     |  __setattr__(self, name, value, /)
     |      Implement setattr(self, name, value).
     |  
     |  __setstate__(...)
     |  
     |  __str__(self, /)
     |      Return str(self).
     |  
     |  with_traceback(...)
     |      Exception.with_traceback(tb) --
     |      set self.__traceback__ to tb and return self.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from builtins.BaseException:
     |  
     |  __cause__
     |      exception cause
     |  
     |  __context__
     |      exception context
     |  
     |  __dict__
     |  
     |  __suppress_context__
     |  
     |  __traceback__
     |  
     |  args

FUNCTIONS
    clear_caches()
        Jinja2 keeps internal caches for environments and lexers.  These are
        used so that Jinja2 doesn't have to recreate environments and lexers all
        the time.  Normally you don't have to care about that but if you are
        measuring memory consumption you may want to clean the caches.
    
    contextfilter(f)
        Decorator for marking context dependent filters. The current
        :class:`Context` will be passed as first argument.
    
    contextfunction(f)
        This decorator can be used to mark a function or method context callable.
        A context callable is passed the active :class:`Context` as first argument when
        called from the template.  This is useful if a function wants to get access
        to the context or functions provided on the context object.  For example
        a function that returns a sorted list of template variables the current
        template exports could look like this::
        
            @contextfunction
            def get_exported_names(context):
                return sorted(context.exported_vars)
    
    environmentfilter(f)
        Decorator for marking environment dependent filters.  The current
        :class:`Environment` is passed to the filter as first argument.
    
    environmentfunction(f)
        This decorator can be used to mark a function or method as environment
        callable.  This decorator works exactly like the :func:`contextfunction`
        decorator just that the first argument is the active :class:`Environment`
        and not context.
    
    escape(...)
        escape(s) -> markup
        
        Convert the characters &, <, >, ', and " in string s to HTML-safe
        sequences.  Use this if you need to display text that might contain
        such characters in HTML.  Marks return value as markup string.
    
    evalcontextfilter(f)
        Decorator for marking eval-context dependent filters.  An eval
        context object is passed as first argument.  For more information
        about the eval context, see :ref:`eval-context`.
        
        .. versionadded:: 2.4
    
    evalcontextfunction(f)
        This decorator can be used to mark a function or method as an eval
        context callable.  This is similar to the :func:`contextfunction`
        but instead of passing the context, an evaluation context object is
        passed.  For more information about the eval context, see
        :ref:`eval-context`.
        
        .. versionadded:: 2.4
    
    is_undefined(obj)
        Check if the object passed is undefined.  This does nothing more than
        performing an instance check against :class:`Undefined` but looks nicer.
        This can be used for custom filters or tests that want to react to
        undefined variables.  For example a custom default filter can look like
        this::
        
            def default(var, default=''):
                if is_undefined(var):
                    return default
                return var
    
    make_logging_undefined(logger=None, base=None)
        Given a logger object this returns a new undefined class that will
        log certain failures.  It will log iterations and printing.  If no
        logger is given a default logger is created.
        
        Example::
        
            logger = logging.getLogger(__name__)
            LoggingUndefined = make_logging_undefined(
                logger=logger,
                base=Undefined
            )
        
        .. versionadded:: 2.8
        
        :param logger: the logger to use.  If not provided, a default logger
                       is created.
        :param base: the base class to add logging functionality to.  This
                     defaults to :class:`Undefined`.
    
    select_autoescape(enabled_extensions=('html', 'htm', 'xml'), disabled_extensions=(), default_for_string=True, default=False)
        Intelligently sets the initial value of autoescaping based on the
        filename of the template.  This is the recommended way to configure
        autoescaping if you do not want to write a custom function yourself.
        
        If you want to enable it for all templates created from strings or
        for all templates with `.html` and `.xml` extensions::
        
            from jinja2 import Environment, select_autoescape
            env = Environment(autoescape=select_autoescape(
                enabled_extensions=('html', 'xml'),
                default_for_string=True,
            ))
        
        Example configuration to turn it on at all times except if the template
        ends with `.txt`::
        
            from jinja2 import Environment, select_autoescape
            env = Environment(autoescape=select_autoescape(
                disabled_extensions=('txt',),
                default_for_string=True,
                default=True,
            ))
        
        The `enabled_extensions` is an iterable of all the extensions that
        autoescaping should be enabled for.  Likewise `disabled_extensions` is
        a list of all templates it should be disabled for.  If a template is
        loaded from a string then the default from `default_for_string` is used.
        If nothing matches then the initial value of autoescaping is set to the
        value of `default`.
        
        For security reasons this function operates case insensitive.
        
        .. versionadded:: 2.9

DATA
    __all__ = ['Environment', 'Template', 'BaseLoader', 'FileSystemLoader'...
    __docformat__ = 'restructuredtext en'

VERSION
    2.10

FILE
    /Users/jack/miniconda2/envs/py37/lib/python3.6/site-packages/jinja2/__init__.py


