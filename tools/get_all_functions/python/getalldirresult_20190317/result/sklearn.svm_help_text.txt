Help on package sklearn.svm in sklearn:

NAME
    sklearn.svm - The :mod:`sklearn.svm` module includes Support Vector Machine algorithms.

PACKAGE CONTENTS
    base
    bounds
    classes
    liblinear
    libsvm
    libsvm_sparse
    setup
    tests (package)

CLASSES
    sklearn.base.BaseEstimator(builtins.object)
        sklearn.svm.classes.LinearSVC(sklearn.base.BaseEstimator, sklearn.linear_model.base.LinearClassifierMixin, sklearn.linear_model.base.SparseCoefMixin)
    sklearn.base.RegressorMixin(builtins.object)
        sklearn.svm.classes.LinearSVR(sklearn.linear_model.base.LinearModel, sklearn.base.RegressorMixin)
        sklearn.svm.classes.NuSVR(sklearn.svm.base.BaseLibSVM, sklearn.base.RegressorMixin)
        sklearn.svm.classes.SVR(sklearn.svm.base.BaseLibSVM, sklearn.base.RegressorMixin)
    sklearn.linear_model.base.LinearClassifierMixin(sklearn.base.ClassifierMixin)
        sklearn.svm.classes.LinearSVC(sklearn.base.BaseEstimator, sklearn.linear_model.base.LinearClassifierMixin, sklearn.linear_model.base.SparseCoefMixin)
    sklearn.linear_model.base.LinearModel(abc.NewBase)
        sklearn.svm.classes.LinearSVR(sklearn.linear_model.base.LinearModel, sklearn.base.RegressorMixin)
    sklearn.linear_model.base.SparseCoefMixin(builtins.object)
        sklearn.svm.classes.LinearSVC(sklearn.base.BaseEstimator, sklearn.linear_model.base.LinearClassifierMixin, sklearn.linear_model.base.SparseCoefMixin)
    sklearn.svm.base.BaseLibSVM(abc.NewBase)
        sklearn.svm.classes.NuSVR(sklearn.svm.base.BaseLibSVM, sklearn.base.RegressorMixin)
        sklearn.svm.classes.OneClassSVM
        sklearn.svm.classes.SVR(sklearn.svm.base.BaseLibSVM, sklearn.base.RegressorMixin)
    sklearn.svm.base.BaseSVC(abc.NewBase)
        sklearn.svm.classes.NuSVC
        sklearn.svm.classes.SVC
    
    class LinearSVC(sklearn.base.BaseEstimator, sklearn.linear_model.base.LinearClassifierMixin, sklearn.linear_model.base.SparseCoefMixin)
     |  Linear Support Vector Classification.
     |  
     |  Similar to SVC with parameter kernel='linear', but implemented in terms of
     |  liblinear rather than libsvm, so it has more flexibility in the choice of
     |  penalties and loss functions and should scale better to large numbers of
     |  samples.
     |  
     |  This class supports both dense and sparse input and the multiclass support
     |  is handled according to a one-vs-the-rest scheme.
     |  
     |  Read more in the :ref:`User Guide <svm_classification>`.
     |  
     |  Parameters
     |  ----------
     |  penalty : string, 'l1' or 'l2' (default='l2')
     |      Specifies the norm used in the penalization. The 'l2'
     |      penalty is the standard used in SVC. The 'l1' leads to ``coef_``
     |      vectors that are sparse.
     |  
     |  loss : string, 'hinge' or 'squared_hinge' (default='squared_hinge')
     |      Specifies the loss function. 'hinge' is the standard SVM loss
     |      (used e.g. by the SVC class) while 'squared_hinge' is the
     |      square of the hinge loss.
     |  
     |  dual : bool, (default=True)
     |      Select the algorithm to either solve the dual or primal
     |      optimization problem. Prefer dual=False when n_samples > n_features.
     |  
     |  tol : float, optional (default=1e-4)
     |      Tolerance for stopping criteria.
     |  
     |  C : float, optional (default=1.0)
     |      Penalty parameter C of the error term.
     |  
     |  multi_class : string, 'ovr' or 'crammer_singer' (default='ovr')
     |      Determines the multi-class strategy if `y` contains more than
     |      two classes.
     |      ``"ovr"`` trains n_classes one-vs-rest classifiers, while
     |      ``"crammer_singer"`` optimizes a joint objective over all classes.
     |      While `crammer_singer` is interesting from a theoretical perspective
     |      as it is consistent, it is seldom used in practice as it rarely leads
     |      to better accuracy and is more expensive to compute.
     |      If ``"crammer_singer"`` is chosen, the options loss, penalty and dual
     |      will be ignored.
     |  
     |  fit_intercept : boolean, optional (default=True)
     |      Whether to calculate the intercept for this model. If set
     |      to false, no intercept will be used in calculations
     |      (i.e. data is expected to be already centered).
     |  
     |  intercept_scaling : float, optional (default=1)
     |      When self.fit_intercept is True, instance vector x becomes
     |      ``[x, self.intercept_scaling]``,
     |      i.e. a "synthetic" feature with constant value equals to
     |      intercept_scaling is appended to the instance vector.
     |      The intercept becomes intercept_scaling * synthetic feature weight
     |      Note! the synthetic feature weight is subject to l1/l2 regularization
     |      as all other features.
     |      To lessen the effect of regularization on synthetic feature weight
     |      (and therefore on the intercept) intercept_scaling has to be increased.
     |  
     |  class_weight : {dict, 'balanced'}, optional
     |      Set the parameter C of class i to ``class_weight[i]*C`` for
     |      SVC. If not given, all classes are supposed to have
     |      weight one.
     |      The "balanced" mode uses the values of y to automatically adjust
     |      weights inversely proportional to class frequencies in the input data
     |      as ``n_samples / (n_classes * np.bincount(y))``
     |  
     |  verbose : int, (default=0)
     |      Enable verbose output. Note that this setting takes advantage of a
     |      per-process runtime setting in liblinear that, if enabled, may not work
     |      properly in a multithreaded context.
     |  
     |  random_state : int, RandomState instance or None, optional (default=None)
     |      The seed of the pseudo random number generator to use when shuffling
     |      the data.  If int, random_state is the seed used by the random number
     |      generator; If RandomState instance, random_state is the random number
     |      generator; If None, the random number generator is the RandomState
     |      instance used by `np.random`.
     |  
     |  max_iter : int, (default=1000)
     |      The maximum number of iterations to be run.
     |  
     |  Attributes
     |  ----------
     |  coef_ : array, shape = [n_features] if n_classes == 2 else [n_classes, n_features]
     |      Weights assigned to the features (coefficients in the primal
     |      problem). This is only available in the case of a linear kernel.
     |  
     |      ``coef_`` is a readonly property derived from ``raw_coef_`` that
     |      follows the internal memory layout of liblinear.
     |  
     |  intercept_ : array, shape = [1] if n_classes == 2 else [n_classes]
     |      Constants in decision function.
     |  
     |  Examples
     |  --------
     |  >>> from sklearn.svm import LinearSVC
     |  >>> from sklearn.datasets import make_classification
     |  >>> X, y = make_classification(n_features=4, random_state=0)
     |  >>> clf = LinearSVC(random_state=0)
     |  >>> clf.fit(X, y)
     |  LinearSVC(C=1.0, class_weight=None, dual=True, fit_intercept=True,
     |       intercept_scaling=1, loss='squared_hinge', max_iter=1000,
     |       multi_class='ovr', penalty='l2', random_state=0, tol=0.0001,
     |       verbose=0)
     |  >>> print(clf.coef_)
     |  [[ 0.08551385  0.39414796  0.49847831  0.37513797]]
     |  >>> print(clf.intercept_)
     |  [ 0.28418066]
     |  >>> print(clf.predict([[0, 0, 0, 0]]))
     |  [1]
     |  
     |  Notes
     |  -----
     |  The underlying C implementation uses a random number generator to
     |  select features when fitting the model. It is thus not uncommon
     |  to have slightly different results for the same input data. If
     |  that happens, try with a smaller ``tol`` parameter.
     |  
     |  The underlying implementation, liblinear, uses a sparse internal
     |  representation for the data that will incur a memory copy.
     |  
     |  Predict output may not match that of standalone liblinear in certain
     |  cases. See :ref:`differences from liblinear <liblinear_differences>`
     |  in the narrative documentation.
     |  
     |  References
     |  ----------
     |  `LIBLINEAR: A Library for Large Linear Classification
     |  <http://www.csie.ntu.edu.tw/~cjlin/liblinear/>`__
     |  
     |  See also
     |  --------
     |  SVC
     |      Implementation of Support Vector Machine classifier using libsvm:
     |      the kernel can be non-linear but its SMO algorithm does not
     |      scale to large number of samples as LinearSVC does.
     |  
     |      Furthermore SVC multi-class mode is implemented using one
     |      vs one scheme while LinearSVC uses one vs the rest. It is
     |      possible to implement one vs the rest with SVC by using the
     |      :class:`sklearn.multiclass.OneVsRestClassifier` wrapper.
     |  
     |      Finally SVC can fit dense data without memory copy if the input
     |      is C-contiguous. Sparse data will still incur memory copy though.
     |  
     |  sklearn.linear_model.SGDClassifier
     |      SGDClassifier can optimize the same cost function as LinearSVC
     |      by adjusting the penalty and loss parameters. In addition it requires
     |      less memory, allows incremental (online) learning, and implements
     |      various loss functions and regularization regimes.
     |  
     |  Method resolution order:
     |      LinearSVC
     |      sklearn.base.BaseEstimator
     |      sklearn.linear_model.base.LinearClassifierMixin
     |      sklearn.base.ClassifierMixin
     |      sklearn.linear_model.base.SparseCoefMixin
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, penalty='l2', loss='squared_hinge', dual=True, tol=0.0001, C=1.0, multi_class='ovr', fit_intercept=True, intercept_scaling=1, class_weight=None, verbose=0, random_state=None, max_iter=1000)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  fit(self, X, y, sample_weight=None)
     |      Fit the model according to the given training data.
     |      
     |      Parameters
     |      ----------
     |      X : {array-like, sparse matrix}, shape = [n_samples, n_features]
     |          Training vector, where n_samples in the number of samples and
     |          n_features is the number of features.
     |      
     |      y : array-like, shape = [n_samples]
     |          Target vector relative to X
     |      
     |      sample_weight : array-like, shape = [n_samples], optional
     |          Array of weights that are assigned to individual
     |          samples. If not provided,
     |          then each sample is given unit weight.
     |      
     |      Returns
     |      -------
     |      self : object
     |          Returns self.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from sklearn.base.BaseEstimator:
     |  
     |  __getstate__(self)
     |  
     |  __repr__(self)
     |      Return repr(self).
     |  
     |  __setstate__(self, state)
     |  
     |  get_params(self, deep=True)
     |      Get parameters for this estimator.
     |      
     |      Parameters
     |      ----------
     |      deep : boolean, optional
     |          If True, will return the parameters for this estimator and
     |          contained subobjects that are estimators.
     |      
     |      Returns
     |      -------
     |      params : mapping of string to any
     |          Parameter names mapped to their values.
     |  
     |  set_params(self, **params)
     |      Set the parameters of this estimator.
     |      
     |      The method works on simple estimators as well as on nested objects
     |      (such as pipelines). The latter have parameters of the form
     |      ``<component>__<parameter>`` so that it's possible to update each
     |      component of a nested object.
     |      
     |      Returns
     |      -------
     |      self
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from sklearn.base.BaseEstimator:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from sklearn.linear_model.base.LinearClassifierMixin:
     |  
     |  decision_function(self, X)
     |      Predict confidence scores for samples.
     |      
     |      The confidence score for a sample is the signed distance of that
     |      sample to the hyperplane.
     |      
     |      Parameters
     |      ----------
     |      X : {array-like, sparse matrix}, shape = (n_samples, n_features)
     |          Samples.
     |      
     |      Returns
     |      -------
     |      array, shape=(n_samples,) if n_classes == 2 else (n_samples, n_classes)
     |          Confidence scores per (sample, class) combination. In the binary
     |          case, confidence score for self.classes_[1] where >0 means this
     |          class would be predicted.
     |  
     |  predict(self, X)
     |      Predict class labels for samples in X.
     |      
     |      Parameters
     |      ----------
     |      X : {array-like, sparse matrix}, shape = [n_samples, n_features]
     |          Samples.
     |      
     |      Returns
     |      -------
     |      C : array, shape = [n_samples]
     |          Predicted class label per sample.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from sklearn.base.ClassifierMixin:
     |  
     |  score(self, X, y, sample_weight=None)
     |      Returns the mean accuracy on the given test data and labels.
     |      
     |      In multi-label classification, this is the subset accuracy
     |      which is a harsh metric since you require for each sample that
     |      each label set be correctly predicted.
     |      
     |      Parameters
     |      ----------
     |      X : array-like, shape = (n_samples, n_features)
     |          Test samples.
     |      
     |      y : array-like, shape = (n_samples) or (n_samples, n_outputs)
     |          True labels for X.
     |      
     |      sample_weight : array-like, shape = [n_samples], optional
     |          Sample weights.
     |      
     |      Returns
     |      -------
     |      score : float
     |          Mean accuracy of self.predict(X) wrt. y.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from sklearn.linear_model.base.SparseCoefMixin:
     |  
     |  densify(self)
     |      Convert coefficient matrix to dense array format.
     |      
     |      Converts the ``coef_`` member (back) to a numpy.ndarray. This is the
     |      default format of ``coef_`` and is required for fitting, so calling
     |      this method is only required on models that have previously been
     |      sparsified; otherwise, it is a no-op.
     |      
     |      Returns
     |      -------
     |      self : estimator
     |  
     |  sparsify(self)
     |      Convert coefficient matrix to sparse format.
     |      
     |      Converts the ``coef_`` member to a scipy.sparse matrix, which for
     |      L1-regularized models can be much more memory- and storage-efficient
     |      than the usual numpy.ndarray representation.
     |      
     |      The ``intercept_`` member is not converted.
     |      
     |      Notes
     |      -----
     |      For non-sparse models, i.e. when there are not many zeros in ``coef_``,
     |      this may actually *increase* memory usage, so use this method with
     |      care. A rule of thumb is that the number of zero elements, which can
     |      be computed with ``(coef_ == 0).sum()``, must be more than 50% for this
     |      to provide significant benefits.
     |      
     |      After calling this method, further fitting with the partial_fit
     |      method (if any) will not work until you call densify.
     |      
     |      Returns
     |      -------
     |      self : estimator
    
    class LinearSVR(sklearn.linear_model.base.LinearModel, sklearn.base.RegressorMixin)
     |  Linear Support Vector Regression.
     |  
     |  Similar to SVR with parameter kernel='linear', but implemented in terms of
     |  liblinear rather than libsvm, so it has more flexibility in the choice of
     |  penalties and loss functions and should scale better to large numbers of
     |  samples.
     |  
     |  This class supports both dense and sparse input.
     |  
     |  Read more in the :ref:`User Guide <svm_regression>`.
     |  
     |  Parameters
     |  ----------
     |  C : float, optional (default=1.0)
     |      Penalty parameter C of the error term. The penalty is a squared
     |      l2 penalty. The bigger this parameter, the less regularization is used.
     |  
     |  loss : string, 'epsilon_insensitive' or 'squared_epsilon_insensitive' (default='epsilon_insensitive')
     |      Specifies the loss function. 'l1' is the epsilon-insensitive loss
     |      (standard SVR) while 'l2' is the squared epsilon-insensitive loss.
     |  
     |  epsilon : float, optional (default=0.1)
     |      Epsilon parameter in the epsilon-insensitive loss function. Note
     |      that the value of this parameter depends on the scale of the target
     |      variable y. If unsure, set ``epsilon=0``.
     |  
     |  dual : bool, (default=True)
     |      Select the algorithm to either solve the dual or primal
     |      optimization problem. Prefer dual=False when n_samples > n_features.
     |  
     |  tol : float, optional (default=1e-4)
     |      Tolerance for stopping criteria.
     |  
     |  fit_intercept : boolean, optional (default=True)
     |      Whether to calculate the intercept for this model. If set
     |      to false, no intercept will be used in calculations
     |      (i.e. data is expected to be already centered).
     |  
     |  intercept_scaling : float, optional (default=1)
     |      When self.fit_intercept is True, instance vector x becomes
     |      [x, self.intercept_scaling],
     |      i.e. a "synthetic" feature with constant value equals to
     |      intercept_scaling is appended to the instance vector.
     |      The intercept becomes intercept_scaling * synthetic feature weight
     |      Note! the synthetic feature weight is subject to l1/l2 regularization
     |      as all other features.
     |      To lessen the effect of regularization on synthetic feature weight
     |      (and therefore on the intercept) intercept_scaling has to be increased.
     |  
     |  verbose : int, (default=0)
     |      Enable verbose output. Note that this setting takes advantage of a
     |      per-process runtime setting in liblinear that, if enabled, may not work
     |      properly in a multithreaded context.
     |  
     |  random_state : int, RandomState instance or None, optional (default=None)
     |      The seed of the pseudo random number generator to use when shuffling
     |      the data.  If int, random_state is the seed used by the random number
     |      generator; If RandomState instance, random_state is the random number
     |      generator; If None, the random number generator is the RandomState
     |      instance used by `np.random`.
     |  
     |  max_iter : int, (default=1000)
     |      The maximum number of iterations to be run.
     |  
     |  Attributes
     |  ----------
     |  coef_ : array, shape = [n_features] if n_classes == 2 else [n_classes, n_features]
     |      Weights assigned to the features (coefficients in the primal
     |      problem). This is only available in the case of a linear kernel.
     |  
     |      `coef_` is a readonly property derived from `raw_coef_` that
     |      follows the internal memory layout of liblinear.
     |  
     |  intercept_ : array, shape = [1] if n_classes == 2 else [n_classes]
     |      Constants in decision function.
     |  
     |  Examples
     |  --------
     |  >>> from sklearn.svm import LinearSVR
     |  >>> from sklearn.datasets import make_regression
     |  >>> X, y = make_regression(n_features=4, random_state=0)
     |  >>> regr = LinearSVR(random_state=0)
     |  >>> regr.fit(X, y)
     |  LinearSVR(C=1.0, dual=True, epsilon=0.0, fit_intercept=True,
     |       intercept_scaling=1.0, loss='epsilon_insensitive', max_iter=1000,
     |       random_state=0, tol=0.0001, verbose=0)
     |  >>> print(regr.coef_)
     |  [ 16.35750999  26.91499923  42.30652207  60.47843124]
     |  >>> print(regr.intercept_)
     |  [-4.29756543]
     |  >>> print(regr.predict([[0, 0, 0, 0]]))
     |  [-4.29756543]
     |  
     |  See also
     |  --------
     |  LinearSVC
     |      Implementation of Support Vector Machine classifier using the
     |      same library as this class (liblinear).
     |  
     |  SVR
     |      Implementation of Support Vector Machine regression using libsvm:
     |      the kernel can be non-linear but its SMO algorithm does not
     |      scale to large number of samples as LinearSVC does.
     |  
     |  sklearn.linear_model.SGDRegressor
     |      SGDRegressor can optimize the same cost function as LinearSVR
     |      by adjusting the penalty and loss parameters. In addition it requires
     |      less memory, allows incremental (online) learning, and implements
     |      various loss functions and regularization regimes.
     |  
     |  Method resolution order:
     |      LinearSVR
     |      sklearn.linear_model.base.LinearModel
     |      abc.NewBase
     |      sklearn.base.BaseEstimator
     |      sklearn.base.RegressorMixin
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, epsilon=0.0, tol=0.0001, C=1.0, loss='epsilon_insensitive', fit_intercept=True, intercept_scaling=1.0, dual=True, verbose=0, random_state=None, max_iter=1000)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  fit(self, X, y, sample_weight=None)
     |      Fit the model according to the given training data.
     |      
     |      Parameters
     |      ----------
     |      X : {array-like, sparse matrix}, shape = [n_samples, n_features]
     |          Training vector, where n_samples in the number of samples and
     |          n_features is the number of features.
     |      
     |      y : array-like, shape = [n_samples]
     |          Target vector relative to X
     |      
     |      sample_weight : array-like, shape = [n_samples], optional
     |          Array of weights that are assigned to individual
     |          samples. If not provided,
     |          then each sample is given unit weight.
     |      
     |      Returns
     |      -------
     |      self : object
     |          Returns self.
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __abstractmethods__ = frozenset()
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from sklearn.linear_model.base.LinearModel:
     |  
     |  predict(self, X)
     |      Predict using the linear model
     |      
     |      Parameters
     |      ----------
     |      X : {array-like, sparse matrix}, shape = (n_samples, n_features)
     |          Samples.
     |      
     |      Returns
     |      -------
     |      C : array, shape = (n_samples,)
     |          Returns predicted values.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from sklearn.base.BaseEstimator:
     |  
     |  __getstate__(self)
     |  
     |  __repr__(self)
     |      Return repr(self).
     |  
     |  __setstate__(self, state)
     |  
     |  get_params(self, deep=True)
     |      Get parameters for this estimator.
     |      
     |      Parameters
     |      ----------
     |      deep : boolean, optional
     |          If True, will return the parameters for this estimator and
     |          contained subobjects that are estimators.
     |      
     |      Returns
     |      -------
     |      params : mapping of string to any
     |          Parameter names mapped to their values.
     |  
     |  set_params(self, **params)
     |      Set the parameters of this estimator.
     |      
     |      The method works on simple estimators as well as on nested objects
     |      (such as pipelines). The latter have parameters of the form
     |      ``<component>__<parameter>`` so that it's possible to update each
     |      component of a nested object.
     |      
     |      Returns
     |      -------
     |      self
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from sklearn.base.BaseEstimator:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from sklearn.base.RegressorMixin:
     |  
     |  score(self, X, y, sample_weight=None)
     |      Returns the coefficient of determination R^2 of the prediction.
     |      
     |      The coefficient R^2 is defined as (1 - u/v), where u is the residual
     |      sum of squares ((y_true - y_pred) ** 2).sum() and v is the total
     |      sum of squares ((y_true - y_true.mean()) ** 2).sum().
     |      The best possible score is 1.0 and it can be negative (because the
     |      model can be arbitrarily worse). A constant model that always
     |      predicts the expected value of y, disregarding the input features,
     |      would get a R^2 score of 0.0.
     |      
     |      Parameters
     |      ----------
     |      X : array-like, shape = (n_samples, n_features)
     |          Test samples.
     |      
     |      y : array-like, shape = (n_samples) or (n_samples, n_outputs)
     |          True values for X.
     |      
     |      sample_weight : array-like, shape = [n_samples], optional
     |          Sample weights.
     |      
     |      Returns
     |      -------
     |      score : float
     |          R^2 of self.predict(X) wrt. y.
    
    class NuSVC(sklearn.svm.base.BaseSVC)
     |  Nu-Support Vector Classification.
     |  
     |  Similar to SVC but uses a parameter to control the number of support
     |  vectors.
     |  
     |  The implementation is based on libsvm.
     |  
     |  Read more in the :ref:`User Guide <svm_classification>`.
     |  
     |  Parameters
     |  ----------
     |  nu : float, optional (default=0.5)
     |      An upper bound on the fraction of training errors and a lower
     |      bound of the fraction of support vectors. Should be in the
     |      interval (0, 1].
     |  
     |  kernel : string, optional (default='rbf')
     |       Specifies the kernel type to be used in the algorithm.
     |       It must be one of 'linear', 'poly', 'rbf', 'sigmoid', 'precomputed' or
     |       a callable.
     |       If none is given, 'rbf' will be used. If a callable is given it is
     |       used to precompute the kernel matrix.
     |  
     |  degree : int, optional (default=3)
     |      Degree of the polynomial kernel function ('poly').
     |      Ignored by all other kernels.
     |  
     |  gamma : float, optional (default='auto')
     |      Kernel coefficient for 'rbf', 'poly' and 'sigmoid'.
     |      If gamma is 'auto' then 1/n_features will be used instead.
     |  
     |  coef0 : float, optional (default=0.0)
     |      Independent term in kernel function.
     |      It is only significant in 'poly' and 'sigmoid'.
     |  
     |  probability : boolean, optional (default=False)
     |      Whether to enable probability estimates. This must be enabled prior
     |      to calling `fit`, and will slow down that method.
     |  
     |  shrinking : boolean, optional (default=True)
     |      Whether to use the shrinking heuristic.
     |  
     |  tol : float, optional (default=1e-3)
     |      Tolerance for stopping criterion.
     |  
     |  cache_size : float, optional
     |      Specify the size of the kernel cache (in MB).
     |  
     |  class_weight : {dict, 'balanced'}, optional
     |      Set the parameter C of class i to class_weight[i]*C for
     |      SVC. If not given, all classes are supposed to have
     |      weight one. The "balanced" mode uses the values of y to automatically
     |      adjust weights inversely proportional to class frequencies as
     |      ``n_samples / (n_classes * np.bincount(y))``
     |  
     |  verbose : bool, default: False
     |      Enable verbose output. Note that this setting takes advantage of a
     |      per-process runtime setting in libsvm that, if enabled, may not work
     |      properly in a multithreaded context.
     |  
     |  max_iter : int, optional (default=-1)
     |      Hard limit on iterations within solver, or -1 for no limit.
     |  
     |  decision_function_shape : 'ovo', 'ovr', default='ovr'
     |      Whether to return a one-vs-rest ('ovr') decision function of shape
     |      (n_samples, n_classes) as all other classifiers, or the original
     |      one-vs-one ('ovo') decision function of libsvm which has shape
     |      (n_samples, n_classes * (n_classes - 1) / 2).
     |  
     |      .. versionchanged:: 0.19
     |          decision_function_shape is 'ovr' by default.
     |  
     |      .. versionadded:: 0.17
     |         *decision_function_shape='ovr'* is recommended.
     |  
     |      .. versionchanged:: 0.17
     |         Deprecated *decision_function_shape='ovo' and None*.
     |  
     |  random_state : int, RandomState instance or None, optional (default=None)
     |      The seed of the pseudo random number generator to use when shuffling
     |      the data.  If int, random_state is the seed used by the random number
     |      generator; If RandomState instance, random_state is the random number
     |      generator; If None, the random number generator is the RandomState
     |      instance used by `np.random`.
     |  
     |  Attributes
     |  ----------
     |  support_ : array-like, shape = [n_SV]
     |      Indices of support vectors.
     |  
     |  support_vectors_ : array-like, shape = [n_SV, n_features]
     |      Support vectors.
     |  
     |  n_support_ : array-like, dtype=int32, shape = [n_class]
     |      Number of support vectors for each class.
     |  
     |  dual_coef_ : array, shape = [n_class-1, n_SV]
     |      Coefficients of the support vector in the decision function.
     |      For multiclass, coefficient for all 1-vs-1 classifiers.
     |      The layout of the coefficients in the multiclass case is somewhat
     |      non-trivial. See the section about multi-class classification in
     |      the SVM section of the User Guide for details.
     |  
     |  coef_ : array, shape = [n_class-1, n_features]
     |      Weights assigned to the features (coefficients in the primal
     |      problem). This is only available in the case of a linear kernel.
     |  
     |      `coef_` is readonly property derived from `dual_coef_` and
     |      `support_vectors_`.
     |  
     |  intercept_ : array, shape = [n_class * (n_class-1) / 2]
     |      Constants in decision function.
     |  
     |  Examples
     |  --------
     |  >>> import numpy as np
     |  >>> X = np.array([[-1, -1], [-2, -1], [1, 1], [2, 1]])
     |  >>> y = np.array([1, 1, 2, 2])
     |  >>> from sklearn.svm import NuSVC
     |  >>> clf = NuSVC()
     |  >>> clf.fit(X, y) #doctest: +NORMALIZE_WHITESPACE
     |  NuSVC(cache_size=200, class_weight=None, coef0=0.0,
     |        decision_function_shape='ovr', degree=3, gamma='auto', kernel='rbf',
     |        max_iter=-1, nu=0.5, probability=False, random_state=None,
     |        shrinking=True, tol=0.001, verbose=False)
     |  >>> print(clf.predict([[-0.8, -1]]))
     |  [1]
     |  
     |  See also
     |  --------
     |  SVC
     |      Support Vector Machine for classification using libsvm.
     |  
     |  LinearSVC
     |      Scalable linear Support Vector Machine for classification using
     |      liblinear.
     |  
     |  Method resolution order:
     |      NuSVC
     |      sklearn.svm.base.BaseSVC
     |      abc.NewBase
     |      sklearn.svm.base.BaseLibSVM
     |      abc.NewBase
     |      sklearn.base.BaseEstimator
     |      sklearn.base.ClassifierMixin
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, nu=0.5, kernel='rbf', degree=3, gamma='auto', coef0=0.0, shrinking=True, probability=False, tol=0.001, cache_size=200, class_weight=None, verbose=False, max_iter=-1, decision_function_shape='ovr', random_state=None)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __abstractmethods__ = frozenset()
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from sklearn.svm.base.BaseSVC:
     |  
     |  decision_function(self, X)
     |      Distance of the samples X to the separating hyperplane.
     |      
     |      Parameters
     |      ----------
     |      X : array-like, shape (n_samples, n_features)
     |      
     |      Returns
     |      -------
     |      X : array-like, shape (n_samples, n_classes * (n_classes-1) / 2)
     |          Returns the decision function of the sample for each class
     |          in the model.
     |          If decision_function_shape='ovr', the shape is (n_samples,
     |          n_classes)
     |  
     |  predict(self, X)
     |      Perform classification on samples in X.
     |      
     |      For an one-class model, +1 or -1 is returned.
     |      
     |      Parameters
     |      ----------
     |      X : {array-like, sparse matrix}, shape (n_samples, n_features)
     |          For kernel="precomputed", the expected shape of X is
     |          [n_samples_test, n_samples_train]
     |      
     |      Returns
     |      -------
     |      y_pred : array, shape (n_samples,)
     |          Class labels for samples in X.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from sklearn.svm.base.BaseSVC:
     |  
     |  predict_log_proba
     |      Compute log probabilities of possible outcomes for samples in X.
     |      
     |      The model need to have probability information computed at training
     |      time: fit with attribute `probability` set to True.
     |      
     |      Parameters
     |      ----------
     |      X : array-like, shape (n_samples, n_features)
     |          For kernel="precomputed", the expected shape of X is
     |          [n_samples_test, n_samples_train]
     |      
     |      Returns
     |      -------
     |      T : array-like, shape (n_samples, n_classes)
     |          Returns the log-probabilities of the sample for each class in
     |          the model. The columns correspond to the classes in sorted
     |          order, as they appear in the attribute `classes_`.
     |      
     |      Notes
     |      -----
     |      The probability model is created using cross validation, so
     |      the results can be slightly different than those obtained by
     |      predict. Also, it will produce meaningless results on very small
     |      datasets.
     |  
     |  predict_proba
     |      Compute probabilities of possible outcomes for samples in X.
     |      
     |      The model need to have probability information computed at training
     |      time: fit with attribute `probability` set to True.
     |      
     |      Parameters
     |      ----------
     |      X : array-like, shape (n_samples, n_features)
     |          For kernel="precomputed", the expected shape of X is
     |          [n_samples_test, n_samples_train]
     |      
     |      Returns
     |      -------
     |      T : array-like, shape (n_samples, n_classes)
     |          Returns the probability of the sample for each class in
     |          the model. The columns correspond to the classes in sorted
     |          order, as they appear in the attribute `classes_`.
     |      
     |      Notes
     |      -----
     |      The probability model is created using cross validation, so
     |      the results can be slightly different than those obtained by
     |      predict. Also, it will produce meaningless results on very small
     |      datasets.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from sklearn.svm.base.BaseLibSVM:
     |  
     |  fit(self, X, y, sample_weight=None)
     |      Fit the SVM model according to the given training data.
     |      
     |      Parameters
     |      ----------
     |      X : {array-like, sparse matrix}, shape (n_samples, n_features)
     |          Training vectors, where n_samples is the number of samples
     |          and n_features is the number of features.
     |          For kernel="precomputed", the expected shape of X is
     |          (n_samples, n_samples).
     |      
     |      y : array-like, shape (n_samples,)
     |          Target values (class labels in classification, real numbers in
     |          regression)
     |      
     |      sample_weight : array-like, shape (n_samples,)
     |          Per-sample weights. Rescale C per sample. Higher weights
     |          force the classifier to put more emphasis on these points.
     |      
     |      Returns
     |      -------
     |      self : object
     |          Returns self.
     |      
     |      Notes
     |      ------
     |      If X and y are not C-ordered and contiguous arrays of np.float64 and
     |      X is not a scipy.sparse.csr_matrix, X and/or y may be copied.
     |      
     |      If X is a dense array, then the other methods will not support sparse
     |      matrices as input.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from sklearn.svm.base.BaseLibSVM:
     |  
     |  coef_
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from sklearn.base.BaseEstimator:
     |  
     |  __getstate__(self)
     |  
     |  __repr__(self)
     |      Return repr(self).
     |  
     |  __setstate__(self, state)
     |  
     |  get_params(self, deep=True)
     |      Get parameters for this estimator.
     |      
     |      Parameters
     |      ----------
     |      deep : boolean, optional
     |          If True, will return the parameters for this estimator and
     |          contained subobjects that are estimators.
     |      
     |      Returns
     |      -------
     |      params : mapping of string to any
     |          Parameter names mapped to their values.
     |  
     |  set_params(self, **params)
     |      Set the parameters of this estimator.
     |      
     |      The method works on simple estimators as well as on nested objects
     |      (such as pipelines). The latter have parameters of the form
     |      ``<component>__<parameter>`` so that it's possible to update each
     |      component of a nested object.
     |      
     |      Returns
     |      -------
     |      self
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from sklearn.base.BaseEstimator:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from sklearn.base.ClassifierMixin:
     |  
     |  score(self, X, y, sample_weight=None)
     |      Returns the mean accuracy on the given test data and labels.
     |      
     |      In multi-label classification, this is the subset accuracy
     |      which is a harsh metric since you require for each sample that
     |      each label set be correctly predicted.
     |      
     |      Parameters
     |      ----------
     |      X : array-like, shape = (n_samples, n_features)
     |          Test samples.
     |      
     |      y : array-like, shape = (n_samples) or (n_samples, n_outputs)
     |          True labels for X.
     |      
     |      sample_weight : array-like, shape = [n_samples], optional
     |          Sample weights.
     |      
     |      Returns
     |      -------
     |      score : float
     |          Mean accuracy of self.predict(X) wrt. y.
    
    class NuSVR(sklearn.svm.base.BaseLibSVM, sklearn.base.RegressorMixin)
     |  Nu Support Vector Regression.
     |  
     |  Similar to NuSVC, for regression, uses a parameter nu to control
     |  the number of support vectors. However, unlike NuSVC, where nu
     |  replaces C, here nu replaces the parameter epsilon of epsilon-SVR.
     |  
     |  The implementation is based on libsvm.
     |  
     |  Read more in the :ref:`User Guide <svm_regression>`.
     |  
     |  Parameters
     |  ----------
     |  C : float, optional (default=1.0)
     |      Penalty parameter C of the error term.
     |  
     |  nu : float, optional
     |      An upper bound on the fraction of training errors and a lower bound of
     |      the fraction of support vectors. Should be in the interval (0, 1].  By
     |      default 0.5 will be taken.
     |  
     |  kernel : string, optional (default='rbf')
     |       Specifies the kernel type to be used in the algorithm.
     |       It must be one of 'linear', 'poly', 'rbf', 'sigmoid', 'precomputed' or
     |       a callable.
     |       If none is given, 'rbf' will be used. If a callable is given it is
     |       used to precompute the kernel matrix.
     |  
     |  degree : int, optional (default=3)
     |      Degree of the polynomial kernel function ('poly').
     |      Ignored by all other kernels.
     |  
     |  gamma : float, optional (default='auto')
     |      Kernel coefficient for 'rbf', 'poly' and 'sigmoid'.
     |      If gamma is 'auto' then 1/n_features will be used instead.
     |  
     |  coef0 : float, optional (default=0.0)
     |      Independent term in kernel function.
     |      It is only significant in 'poly' and 'sigmoid'.
     |  
     |  shrinking : boolean, optional (default=True)
     |      Whether to use the shrinking heuristic.
     |  
     |  tol : float, optional (default=1e-3)
     |      Tolerance for stopping criterion.
     |  
     |  cache_size : float, optional
     |      Specify the size of the kernel cache (in MB).
     |  
     |  verbose : bool, default: False
     |      Enable verbose output. Note that this setting takes advantage of a
     |      per-process runtime setting in libsvm that, if enabled, may not work
     |      properly in a multithreaded context.
     |  
     |  max_iter : int, optional (default=-1)
     |      Hard limit on iterations within solver, or -1 for no limit.
     |  
     |  Attributes
     |  ----------
     |  support_ : array-like, shape = [n_SV]
     |      Indices of support vectors.
     |  
     |  support_vectors_ : array-like, shape = [nSV, n_features]
     |      Support vectors.
     |  
     |  dual_coef_ : array, shape = [1, n_SV]
     |      Coefficients of the support vector in the decision function.
     |  
     |  coef_ : array, shape = [1, n_features]
     |      Weights assigned to the features (coefficients in the primal
     |      problem). This is only available in the case of a linear kernel.
     |  
     |      `coef_` is readonly property derived from `dual_coef_` and
     |      `support_vectors_`.
     |  
     |  intercept_ : array, shape = [1]
     |      Constants in decision function.
     |  
     |  Examples
     |  --------
     |  >>> from sklearn.svm import NuSVR
     |  >>> import numpy as np
     |  >>> n_samples, n_features = 10, 5
     |  >>> np.random.seed(0)
     |  >>> y = np.random.randn(n_samples)
     |  >>> X = np.random.randn(n_samples, n_features)
     |  >>> clf = NuSVR(C=1.0, nu=0.1)
     |  >>> clf.fit(X, y)  #doctest: +NORMALIZE_WHITESPACE
     |  NuSVR(C=1.0, cache_size=200, coef0=0.0, degree=3, gamma='auto',
     |        kernel='rbf', max_iter=-1, nu=0.1, shrinking=True, tol=0.001,
     |        verbose=False)
     |  
     |  See also
     |  --------
     |  NuSVC
     |      Support Vector Machine for classification implemented with libsvm
     |      with a parameter to control the number of support vectors.
     |  
     |  SVR
     |      epsilon Support Vector Machine for regression implemented with libsvm.
     |  
     |  Method resolution order:
     |      NuSVR
     |      sklearn.svm.base.BaseLibSVM
     |      abc.NewBase
     |      sklearn.base.BaseEstimator
     |      sklearn.base.RegressorMixin
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, nu=0.5, C=1.0, kernel='rbf', degree=3, gamma='auto', coef0=0.0, shrinking=True, tol=0.001, cache_size=200, verbose=False, max_iter=-1)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __abstractmethods__ = frozenset()
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from sklearn.svm.base.BaseLibSVM:
     |  
     |  fit(self, X, y, sample_weight=None)
     |      Fit the SVM model according to the given training data.
     |      
     |      Parameters
     |      ----------
     |      X : {array-like, sparse matrix}, shape (n_samples, n_features)
     |          Training vectors, where n_samples is the number of samples
     |          and n_features is the number of features.
     |          For kernel="precomputed", the expected shape of X is
     |          (n_samples, n_samples).
     |      
     |      y : array-like, shape (n_samples,)
     |          Target values (class labels in classification, real numbers in
     |          regression)
     |      
     |      sample_weight : array-like, shape (n_samples,)
     |          Per-sample weights. Rescale C per sample. Higher weights
     |          force the classifier to put more emphasis on these points.
     |      
     |      Returns
     |      -------
     |      self : object
     |          Returns self.
     |      
     |      Notes
     |      ------
     |      If X and y are not C-ordered and contiguous arrays of np.float64 and
     |      X is not a scipy.sparse.csr_matrix, X and/or y may be copied.
     |      
     |      If X is a dense array, then the other methods will not support sparse
     |      matrices as input.
     |  
     |  predict(self, X)
     |      Perform regression on samples in X.
     |      
     |      For an one-class model, +1 (inlier) or -1 (outlier) is returned.
     |      
     |      Parameters
     |      ----------
     |      X : {array-like, sparse matrix}, shape (n_samples, n_features)
     |          For kernel="precomputed", the expected shape of X is
     |          (n_samples_test, n_samples_train).
     |      
     |      Returns
     |      -------
     |      y_pred : array, shape (n_samples,)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from sklearn.svm.base.BaseLibSVM:
     |  
     |  coef_
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from sklearn.base.BaseEstimator:
     |  
     |  __getstate__(self)
     |  
     |  __repr__(self)
     |      Return repr(self).
     |  
     |  __setstate__(self, state)
     |  
     |  get_params(self, deep=True)
     |      Get parameters for this estimator.
     |      
     |      Parameters
     |      ----------
     |      deep : boolean, optional
     |          If True, will return the parameters for this estimator and
     |          contained subobjects that are estimators.
     |      
     |      Returns
     |      -------
     |      params : mapping of string to any
     |          Parameter names mapped to their values.
     |  
     |  set_params(self, **params)
     |      Set the parameters of this estimator.
     |      
     |      The method works on simple estimators as well as on nested objects
     |      (such as pipelines). The latter have parameters of the form
     |      ``<component>__<parameter>`` so that it's possible to update each
     |      component of a nested object.
     |      
     |      Returns
     |      -------
     |      self
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from sklearn.base.BaseEstimator:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from sklearn.base.RegressorMixin:
     |  
     |  score(self, X, y, sample_weight=None)
     |      Returns the coefficient of determination R^2 of the prediction.
     |      
     |      The coefficient R^2 is defined as (1 - u/v), where u is the residual
     |      sum of squares ((y_true - y_pred) ** 2).sum() and v is the total
     |      sum of squares ((y_true - y_true.mean()) ** 2).sum().
     |      The best possible score is 1.0 and it can be negative (because the
     |      model can be arbitrarily worse). A constant model that always
     |      predicts the expected value of y, disregarding the input features,
     |      would get a R^2 score of 0.0.
     |      
     |      Parameters
     |      ----------
     |      X : array-like, shape = (n_samples, n_features)
     |          Test samples.
     |      
     |      y : array-like, shape = (n_samples) or (n_samples, n_outputs)
     |          True values for X.
     |      
     |      sample_weight : array-like, shape = [n_samples], optional
     |          Sample weights.
     |      
     |      Returns
     |      -------
     |      score : float
     |          R^2 of self.predict(X) wrt. y.
    
    class OneClassSVM(sklearn.svm.base.BaseLibSVM)
     |  Unsupervised Outlier Detection.
     |  
     |  Estimate the support of a high-dimensional distribution.
     |  
     |  The implementation is based on libsvm.
     |  
     |  Read more in the :ref:`User Guide <svm_outlier_detection>`.
     |  
     |  Parameters
     |  ----------
     |  kernel : string, optional (default='rbf')
     |       Specifies the kernel type to be used in the algorithm.
     |       It must be one of 'linear', 'poly', 'rbf', 'sigmoid', 'precomputed' or
     |       a callable.
     |       If none is given, 'rbf' will be used. If a callable is given it is
     |       used to precompute the kernel matrix.
     |  
     |  nu : float, optional
     |      An upper bound on the fraction of training
     |      errors and a lower bound of the fraction of support
     |      vectors. Should be in the interval (0, 1]. By default 0.5
     |      will be taken.
     |  
     |  degree : int, optional (default=3)
     |      Degree of the polynomial kernel function ('poly').
     |      Ignored by all other kernels.
     |  
     |  gamma : float, optional (default='auto')
     |      Kernel coefficient for 'rbf', 'poly' and 'sigmoid'.
     |      If gamma is 'auto' then 1/n_features will be used instead.
     |  
     |  coef0 : float, optional (default=0.0)
     |      Independent term in kernel function.
     |      It is only significant in 'poly' and 'sigmoid'.
     |  
     |  tol : float, optional
     |      Tolerance for stopping criterion.
     |  
     |  shrinking : boolean, optional
     |      Whether to use the shrinking heuristic.
     |  
     |  cache_size : float, optional
     |      Specify the size of the kernel cache (in MB).
     |  
     |  verbose : bool, default: False
     |      Enable verbose output. Note that this setting takes advantage of a
     |      per-process runtime setting in libsvm that, if enabled, may not work
     |      properly in a multithreaded context.
     |  
     |  max_iter : int, optional (default=-1)
     |      Hard limit on iterations within solver, or -1 for no limit.
     |  
     |  random_state : int, RandomState instance or None, optional (default=None)
     |      The seed of the pseudo random number generator to use when shuffling
     |      the data.  If int, random_state is the seed used by the random number
     |      generator; If RandomState instance, random_state is the random number
     |      generator; If None, the random number generator is the RandomState
     |      instance used by `np.random`.
     |  
     |  Attributes
     |  ----------
     |  support_ : array-like, shape = [n_SV]
     |      Indices of support vectors.
     |  
     |  support_vectors_ : array-like, shape = [nSV, n_features]
     |      Support vectors.
     |  
     |  dual_coef_ : array, shape = [1, n_SV]
     |      Coefficients of the support vectors in the decision function.
     |  
     |  coef_ : array, shape = [1, n_features]
     |      Weights assigned to the features (coefficients in the primal
     |      problem). This is only available in the case of a linear kernel.
     |  
     |      `coef_` is readonly property derived from `dual_coef_` and
     |      `support_vectors_`
     |  
     |  intercept_ : array, shape = [1,]
     |      Constant in the decision function.
     |  
     |  Method resolution order:
     |      OneClassSVM
     |      sklearn.svm.base.BaseLibSVM
     |      abc.NewBase
     |      sklearn.base.BaseEstimator
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, kernel='rbf', degree=3, gamma='auto', coef0=0.0, tol=0.001, nu=0.5, shrinking=True, cache_size=200, verbose=False, max_iter=-1, random_state=None)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  decision_function(self, X)
     |      Signed distance to the separating hyperplane.
     |      
     |      Signed distance is positive for an inlier and negative for an outlier.
     |      
     |      Parameters
     |      ----------
     |      X : array-like, shape (n_samples, n_features)
     |      
     |      Returns
     |      -------
     |      X : array-like, shape (n_samples,)
     |          Returns the decision function of the samples.
     |  
     |  fit(self, X, y=None, sample_weight=None, **params)
     |      Detects the soft boundary of the set of samples X.
     |      
     |      Parameters
     |      ----------
     |      X : {array-like, sparse matrix}, shape (n_samples, n_features)
     |          Set of samples, where n_samples is the number of samples and
     |          n_features is the number of features.
     |      
     |      sample_weight : array-like, shape (n_samples,)
     |          Per-sample weights. Rescale C per sample. Higher weights
     |          force the classifier to put more emphasis on these points.
     |      
     |      Returns
     |      -------
     |      self : object
     |          Returns self.
     |      
     |      Notes
     |      -----
     |      If X is not a C-ordered contiguous array it is copied.
     |  
     |  predict(self, X)
     |      Perform classification on samples in X.
     |      
     |      For an one-class model, +1 or -1 is returned.
     |      
     |      Parameters
     |      ----------
     |      X : {array-like, sparse matrix}, shape (n_samples, n_features)
     |          For kernel="precomputed", the expected shape of X is
     |          [n_samples_test, n_samples_train]
     |      
     |      Returns
     |      -------
     |      y_pred : array, shape (n_samples,)
     |          Class labels for samples in X.
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __abstractmethods__ = frozenset()
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from sklearn.svm.base.BaseLibSVM:
     |  
     |  coef_
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from sklearn.base.BaseEstimator:
     |  
     |  __getstate__(self)
     |  
     |  __repr__(self)
     |      Return repr(self).
     |  
     |  __setstate__(self, state)
     |  
     |  get_params(self, deep=True)
     |      Get parameters for this estimator.
     |      
     |      Parameters
     |      ----------
     |      deep : boolean, optional
     |          If True, will return the parameters for this estimator and
     |          contained subobjects that are estimators.
     |      
     |      Returns
     |      -------
     |      params : mapping of string to any
     |          Parameter names mapped to their values.
     |  
     |  set_params(self, **params)
     |      Set the parameters of this estimator.
     |      
     |      The method works on simple estimators as well as on nested objects
     |      (such as pipelines). The latter have parameters of the form
     |      ``<component>__<parameter>`` so that it's possible to update each
     |      component of a nested object.
     |      
     |      Returns
     |      -------
     |      self
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from sklearn.base.BaseEstimator:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class SVC(sklearn.svm.base.BaseSVC)
     |  C-Support Vector Classification.
     |  
     |  The implementation is based on libsvm. The fit time complexity
     |  is more than quadratic with the number of samples which makes it hard
     |  to scale to dataset with more than a couple of 10000 samples.
     |  
     |  The multiclass support is handled according to a one-vs-one scheme.
     |  
     |  For details on the precise mathematical formulation of the provided
     |  kernel functions and how `gamma`, `coef0` and `degree` affect each
     |  other, see the corresponding section in the narrative documentation:
     |  :ref:`svm_kernels`.
     |  
     |  Read more in the :ref:`User Guide <svm_classification>`.
     |  
     |  Parameters
     |  ----------
     |  C : float, optional (default=1.0)
     |      Penalty parameter C of the error term.
     |  
     |  kernel : string, optional (default='rbf')
     |       Specifies the kernel type to be used in the algorithm.
     |       It must be one of 'linear', 'poly', 'rbf', 'sigmoid', 'precomputed' or
     |       a callable.
     |       If none is given, 'rbf' will be used. If a callable is given it is
     |       used to pre-compute the kernel matrix from data matrices; that matrix
     |       should be an array of shape ``(n_samples, n_samples)``.
     |  
     |  degree : int, optional (default=3)
     |      Degree of the polynomial kernel function ('poly').
     |      Ignored by all other kernels.
     |  
     |  gamma : float, optional (default='auto')
     |      Kernel coefficient for 'rbf', 'poly' and 'sigmoid'.
     |      If gamma is 'auto' then 1/n_features will be used instead.
     |  
     |  coef0 : float, optional (default=0.0)
     |      Independent term in kernel function.
     |      It is only significant in 'poly' and 'sigmoid'.
     |  
     |  probability : boolean, optional (default=False)
     |      Whether to enable probability estimates. This must be enabled prior
     |      to calling `fit`, and will slow down that method.
     |  
     |  shrinking : boolean, optional (default=True)
     |      Whether to use the shrinking heuristic.
     |  
     |  tol : float, optional (default=1e-3)
     |      Tolerance for stopping criterion.
     |  
     |  cache_size : float, optional
     |      Specify the size of the kernel cache (in MB).
     |  
     |  class_weight : {dict, 'balanced'}, optional
     |      Set the parameter C of class i to class_weight[i]*C for
     |      SVC. If not given, all classes are supposed to have
     |      weight one.
     |      The "balanced" mode uses the values of y to automatically adjust
     |      weights inversely proportional to class frequencies in the input data
     |      as ``n_samples / (n_classes * np.bincount(y))``
     |  
     |  verbose : bool, default: False
     |      Enable verbose output. Note that this setting takes advantage of a
     |      per-process runtime setting in libsvm that, if enabled, may not work
     |      properly in a multithreaded context.
     |  
     |  max_iter : int, optional (default=-1)
     |      Hard limit on iterations within solver, or -1 for no limit.
     |  
     |  decision_function_shape : 'ovo', 'ovr', default='ovr'
     |      Whether to return a one-vs-rest ('ovr') decision function of shape
     |      (n_samples, n_classes) as all other classifiers, or the original
     |      one-vs-one ('ovo') decision function of libsvm which has shape
     |      (n_samples, n_classes * (n_classes - 1) / 2).
     |  
     |      .. versionchanged:: 0.19
     |          decision_function_shape is 'ovr' by default.
     |  
     |      .. versionadded:: 0.17
     |         *decision_function_shape='ovr'* is recommended.
     |  
     |      .. versionchanged:: 0.17
     |         Deprecated *decision_function_shape='ovo' and None*.
     |  
     |  random_state : int, RandomState instance or None, optional (default=None)
     |      The seed of the pseudo random number generator to use when shuffling
     |      the data.  If int, random_state is the seed used by the random number
     |      generator; If RandomState instance, random_state is the random number
     |      generator; If None, the random number generator is the RandomState
     |      instance used by `np.random`.
     |  
     |  Attributes
     |  ----------
     |  support_ : array-like, shape = [n_SV]
     |      Indices of support vectors.
     |  
     |  support_vectors_ : array-like, shape = [n_SV, n_features]
     |      Support vectors.
     |  
     |  n_support_ : array-like, dtype=int32, shape = [n_class]
     |      Number of support vectors for each class.
     |  
     |  dual_coef_ : array, shape = [n_class-1, n_SV]
     |      Coefficients of the support vector in the decision function.
     |      For multiclass, coefficient for all 1-vs-1 classifiers.
     |      The layout of the coefficients in the multiclass case is somewhat
     |      non-trivial. See the section about multi-class classification in the
     |      SVM section of the User Guide for details.
     |  
     |  coef_ : array, shape = [n_class-1, n_features]
     |      Weights assigned to the features (coefficients in the primal
     |      problem). This is only available in the case of a linear kernel.
     |  
     |      `coef_` is a readonly property derived from `dual_coef_` and
     |      `support_vectors_`.
     |  
     |  intercept_ : array, shape = [n_class * (n_class-1) / 2]
     |      Constants in decision function.
     |  
     |  Examples
     |  --------
     |  >>> import numpy as np
     |  >>> X = np.array([[-1, -1], [-2, -1], [1, 1], [2, 1]])
     |  >>> y = np.array([1, 1, 2, 2])
     |  >>> from sklearn.svm import SVC
     |  >>> clf = SVC()
     |  >>> clf.fit(X, y) #doctest: +NORMALIZE_WHITESPACE
     |  SVC(C=1.0, cache_size=200, class_weight=None, coef0=0.0,
     |      decision_function_shape='ovr', degree=3, gamma='auto', kernel='rbf',
     |      max_iter=-1, probability=False, random_state=None, shrinking=True,
     |      tol=0.001, verbose=False)
     |  >>> print(clf.predict([[-0.8, -1]]))
     |  [1]
     |  
     |  See also
     |  --------
     |  SVR
     |      Support Vector Machine for Regression implemented using libsvm.
     |  
     |  LinearSVC
     |      Scalable Linear Support Vector Machine for classification
     |      implemented using liblinear. Check the See also section of
     |      LinearSVC for more comparison element.
     |  
     |  Method resolution order:
     |      SVC
     |      sklearn.svm.base.BaseSVC
     |      abc.NewBase
     |      sklearn.svm.base.BaseLibSVM
     |      abc.NewBase
     |      sklearn.base.BaseEstimator
     |      sklearn.base.ClassifierMixin
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, C=1.0, kernel='rbf', degree=3, gamma='auto', coef0=0.0, shrinking=True, probability=False, tol=0.001, cache_size=200, class_weight=None, verbose=False, max_iter=-1, decision_function_shape='ovr', random_state=None)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __abstractmethods__ = frozenset()
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from sklearn.svm.base.BaseSVC:
     |  
     |  decision_function(self, X)
     |      Distance of the samples X to the separating hyperplane.
     |      
     |      Parameters
     |      ----------
     |      X : array-like, shape (n_samples, n_features)
     |      
     |      Returns
     |      -------
     |      X : array-like, shape (n_samples, n_classes * (n_classes-1) / 2)
     |          Returns the decision function of the sample for each class
     |          in the model.
     |          If decision_function_shape='ovr', the shape is (n_samples,
     |          n_classes)
     |  
     |  predict(self, X)
     |      Perform classification on samples in X.
     |      
     |      For an one-class model, +1 or -1 is returned.
     |      
     |      Parameters
     |      ----------
     |      X : {array-like, sparse matrix}, shape (n_samples, n_features)
     |          For kernel="precomputed", the expected shape of X is
     |          [n_samples_test, n_samples_train]
     |      
     |      Returns
     |      -------
     |      y_pred : array, shape (n_samples,)
     |          Class labels for samples in X.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from sklearn.svm.base.BaseSVC:
     |  
     |  predict_log_proba
     |      Compute log probabilities of possible outcomes for samples in X.
     |      
     |      The model need to have probability information computed at training
     |      time: fit with attribute `probability` set to True.
     |      
     |      Parameters
     |      ----------
     |      X : array-like, shape (n_samples, n_features)
     |          For kernel="precomputed", the expected shape of X is
     |          [n_samples_test, n_samples_train]
     |      
     |      Returns
     |      -------
     |      T : array-like, shape (n_samples, n_classes)
     |          Returns the log-probabilities of the sample for each class in
     |          the model. The columns correspond to the classes in sorted
     |          order, as they appear in the attribute `classes_`.
     |      
     |      Notes
     |      -----
     |      The probability model is created using cross validation, so
     |      the results can be slightly different than those obtained by
     |      predict. Also, it will produce meaningless results on very small
     |      datasets.
     |  
     |  predict_proba
     |      Compute probabilities of possible outcomes for samples in X.
     |      
     |      The model need to have probability information computed at training
     |      time: fit with attribute `probability` set to True.
     |      
     |      Parameters
     |      ----------
     |      X : array-like, shape (n_samples, n_features)
     |          For kernel="precomputed", the expected shape of X is
     |          [n_samples_test, n_samples_train]
     |      
     |      Returns
     |      -------
     |      T : array-like, shape (n_samples, n_classes)
     |          Returns the probability of the sample for each class in
     |          the model. The columns correspond to the classes in sorted
     |          order, as they appear in the attribute `classes_`.
     |      
     |      Notes
     |      -----
     |      The probability model is created using cross validation, so
     |      the results can be slightly different than those obtained by
     |      predict. Also, it will produce meaningless results on very small
     |      datasets.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from sklearn.svm.base.BaseLibSVM:
     |  
     |  fit(self, X, y, sample_weight=None)
     |      Fit the SVM model according to the given training data.
     |      
     |      Parameters
     |      ----------
     |      X : {array-like, sparse matrix}, shape (n_samples, n_features)
     |          Training vectors, where n_samples is the number of samples
     |          and n_features is the number of features.
     |          For kernel="precomputed", the expected shape of X is
     |          (n_samples, n_samples).
     |      
     |      y : array-like, shape (n_samples,)
     |          Target values (class labels in classification, real numbers in
     |          regression)
     |      
     |      sample_weight : array-like, shape (n_samples,)
     |          Per-sample weights. Rescale C per sample. Higher weights
     |          force the classifier to put more emphasis on these points.
     |      
     |      Returns
     |      -------
     |      self : object
     |          Returns self.
     |      
     |      Notes
     |      ------
     |      If X and y are not C-ordered and contiguous arrays of np.float64 and
     |      X is not a scipy.sparse.csr_matrix, X and/or y may be copied.
     |      
     |      If X is a dense array, then the other methods will not support sparse
     |      matrices as input.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from sklearn.svm.base.BaseLibSVM:
     |  
     |  coef_
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from sklearn.base.BaseEstimator:
     |  
     |  __getstate__(self)
     |  
     |  __repr__(self)
     |      Return repr(self).
     |  
     |  __setstate__(self, state)
     |  
     |  get_params(self, deep=True)
     |      Get parameters for this estimator.
     |      
     |      Parameters
     |      ----------
     |      deep : boolean, optional
     |          If True, will return the parameters for this estimator and
     |          contained subobjects that are estimators.
     |      
     |      Returns
     |      -------
     |      params : mapping of string to any
     |          Parameter names mapped to their values.
     |  
     |  set_params(self, **params)
     |      Set the parameters of this estimator.
     |      
     |      The method works on simple estimators as well as on nested objects
     |      (such as pipelines). The latter have parameters of the form
     |      ``<component>__<parameter>`` so that it's possible to update each
     |      component of a nested object.
     |      
     |      Returns
     |      -------
     |      self
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from sklearn.base.BaseEstimator:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from sklearn.base.ClassifierMixin:
     |  
     |  score(self, X, y, sample_weight=None)
     |      Returns the mean accuracy on the given test data and labels.
     |      
     |      In multi-label classification, this is the subset accuracy
     |      which is a harsh metric since you require for each sample that
     |      each label set be correctly predicted.
     |      
     |      Parameters
     |      ----------
     |      X : array-like, shape = (n_samples, n_features)
     |          Test samples.
     |      
     |      y : array-like, shape = (n_samples) or (n_samples, n_outputs)
     |          True labels for X.
     |      
     |      sample_weight : array-like, shape = [n_samples], optional
     |          Sample weights.
     |      
     |      Returns
     |      -------
     |      score : float
     |          Mean accuracy of self.predict(X) wrt. y.
    
    class SVR(sklearn.svm.base.BaseLibSVM, sklearn.base.RegressorMixin)
     |  Epsilon-Support Vector Regression.
     |  
     |  The free parameters in the model are C and epsilon.
     |  
     |  The implementation is based on libsvm.
     |  
     |  Read more in the :ref:`User Guide <svm_regression>`.
     |  
     |  Parameters
     |  ----------
     |  C : float, optional (default=1.0)
     |      Penalty parameter C of the error term.
     |  
     |  epsilon : float, optional (default=0.1)
     |       Epsilon in the epsilon-SVR model. It specifies the epsilon-tube
     |       within which no penalty is associated in the training loss function
     |       with points predicted within a distance epsilon from the actual
     |       value.
     |  
     |  kernel : string, optional (default='rbf')
     |       Specifies the kernel type to be used in the algorithm.
     |       It must be one of 'linear', 'poly', 'rbf', 'sigmoid', 'precomputed' or
     |       a callable.
     |       If none is given, 'rbf' will be used. If a callable is given it is
     |       used to precompute the kernel matrix.
     |  
     |  degree : int, optional (default=3)
     |      Degree of the polynomial kernel function ('poly').
     |      Ignored by all other kernels.
     |  
     |  gamma : float, optional (default='auto')
     |      Kernel coefficient for 'rbf', 'poly' and 'sigmoid'.
     |      If gamma is 'auto' then 1/n_features will be used instead.
     |  
     |  coef0 : float, optional (default=0.0)
     |      Independent term in kernel function.
     |      It is only significant in 'poly' and 'sigmoid'.
     |  
     |  shrinking : boolean, optional (default=True)
     |      Whether to use the shrinking heuristic.
     |  
     |  tol : float, optional (default=1e-3)
     |      Tolerance for stopping criterion.
     |  
     |  cache_size : float, optional
     |      Specify the size of the kernel cache (in MB).
     |  
     |  verbose : bool, default: False
     |      Enable verbose output. Note that this setting takes advantage of a
     |      per-process runtime setting in libsvm that, if enabled, may not work
     |      properly in a multithreaded context.
     |  
     |  max_iter : int, optional (default=-1)
     |      Hard limit on iterations within solver, or -1 for no limit.
     |  
     |  Attributes
     |  ----------
     |  support_ : array-like, shape = [n_SV]
     |      Indices of support vectors.
     |  
     |  support_vectors_ : array-like, shape = [nSV, n_features]
     |      Support vectors.
     |  
     |  dual_coef_ : array, shape = [1, n_SV]
     |      Coefficients of the support vector in the decision function.
     |  
     |  coef_ : array, shape = [1, n_features]
     |      Weights assigned to the features (coefficients in the primal
     |      problem). This is only available in the case of a linear kernel.
     |  
     |      `coef_` is readonly property derived from `dual_coef_` and
     |      `support_vectors_`.
     |  
     |  intercept_ : array, shape = [1]
     |      Constants in decision function.
     |  
     |  sample_weight : array-like, shape = [n_samples]
     |          Individual weights for each sample
     |  
     |  Examples
     |  --------
     |  >>> from sklearn.svm import SVR
     |  >>> import numpy as np
     |  >>> n_samples, n_features = 10, 5
     |  >>> np.random.seed(0)
     |  >>> y = np.random.randn(n_samples)
     |  >>> X = np.random.randn(n_samples, n_features)
     |  >>> clf = SVR(C=1.0, epsilon=0.2)
     |  >>> clf.fit(X, y) #doctest: +NORMALIZE_WHITESPACE
     |  SVR(C=1.0, cache_size=200, coef0=0.0, degree=3, epsilon=0.2, gamma='auto',
     |      kernel='rbf', max_iter=-1, shrinking=True, tol=0.001, verbose=False)
     |  
     |  See also
     |  --------
     |  NuSVR
     |      Support Vector Machine for regression implemented using libsvm
     |      using a parameter to control the number of support vectors.
     |  
     |  LinearSVR
     |      Scalable Linear Support Vector Machine for regression
     |      implemented using liblinear.
     |  
     |  Method resolution order:
     |      SVR
     |      sklearn.svm.base.BaseLibSVM
     |      abc.NewBase
     |      sklearn.base.BaseEstimator
     |      sklearn.base.RegressorMixin
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, kernel='rbf', degree=3, gamma='auto', coef0=0.0, tol=0.001, C=1.0, epsilon=0.1, shrinking=True, cache_size=200, verbose=False, max_iter=-1)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __abstractmethods__ = frozenset()
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from sklearn.svm.base.BaseLibSVM:
     |  
     |  fit(self, X, y, sample_weight=None)
     |      Fit the SVM model according to the given training data.
     |      
     |      Parameters
     |      ----------
     |      X : {array-like, sparse matrix}, shape (n_samples, n_features)
     |          Training vectors, where n_samples is the number of samples
     |          and n_features is the number of features.
     |          For kernel="precomputed", the expected shape of X is
     |          (n_samples, n_samples).
     |      
     |      y : array-like, shape (n_samples,)
     |          Target values (class labels in classification, real numbers in
     |          regression)
     |      
     |      sample_weight : array-like, shape (n_samples,)
     |          Per-sample weights. Rescale C per sample. Higher weights
     |          force the classifier to put more emphasis on these points.
     |      
     |      Returns
     |      -------
     |      self : object
     |          Returns self.
     |      
     |      Notes
     |      ------
     |      If X and y are not C-ordered and contiguous arrays of np.float64 and
     |      X is not a scipy.sparse.csr_matrix, X and/or y may be copied.
     |      
     |      If X is a dense array, then the other methods will not support sparse
     |      matrices as input.
     |  
     |  predict(self, X)
     |      Perform regression on samples in X.
     |      
     |      For an one-class model, +1 (inlier) or -1 (outlier) is returned.
     |      
     |      Parameters
     |      ----------
     |      X : {array-like, sparse matrix}, shape (n_samples, n_features)
     |          For kernel="precomputed", the expected shape of X is
     |          (n_samples_test, n_samples_train).
     |      
     |      Returns
     |      -------
     |      y_pred : array, shape (n_samples,)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from sklearn.svm.base.BaseLibSVM:
     |  
     |  coef_
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from sklearn.base.BaseEstimator:
     |  
     |  __getstate__(self)
     |  
     |  __repr__(self)
     |      Return repr(self).
     |  
     |  __setstate__(self, state)
     |  
     |  get_params(self, deep=True)
     |      Get parameters for this estimator.
     |      
     |      Parameters
     |      ----------
     |      deep : boolean, optional
     |          If True, will return the parameters for this estimator and
     |          contained subobjects that are estimators.
     |      
     |      Returns
     |      -------
     |      params : mapping of string to any
     |          Parameter names mapped to their values.
     |  
     |  set_params(self, **params)
     |      Set the parameters of this estimator.
     |      
     |      The method works on simple estimators as well as on nested objects
     |      (such as pipelines). The latter have parameters of the form
     |      ``<component>__<parameter>`` so that it's possible to update each
     |      component of a nested object.
     |      
     |      Returns
     |      -------
     |      self
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from sklearn.base.BaseEstimator:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from sklearn.base.RegressorMixin:
     |  
     |  score(self, X, y, sample_weight=None)
     |      Returns the coefficient of determination R^2 of the prediction.
     |      
     |      The coefficient R^2 is defined as (1 - u/v), where u is the residual
     |      sum of squares ((y_true - y_pred) ** 2).sum() and v is the total
     |      sum of squares ((y_true - y_true.mean()) ** 2).sum().
     |      The best possible score is 1.0 and it can be negative (because the
     |      model can be arbitrarily worse). A constant model that always
     |      predicts the expected value of y, disregarding the input features,
     |      would get a R^2 score of 0.0.
     |      
     |      Parameters
     |      ----------
     |      X : array-like, shape = (n_samples, n_features)
     |          Test samples.
     |      
     |      y : array-like, shape = (n_samples) or (n_samples, n_outputs)
     |          True values for X.
     |      
     |      sample_weight : array-like, shape = [n_samples], optional
     |          Sample weights.
     |      
     |      Returns
     |      -------
     |      score : float
     |          R^2 of self.predict(X) wrt. y.

FUNCTIONS
    l1_min_c(X, y, loss='squared_hinge', fit_intercept=True, intercept_scaling=1.0)
        Return the lowest bound for C such that for C in (l1_min_C, infinity)
        the model is guaranteed not to be empty. This applies to l1 penalized
        classifiers, such as LinearSVC with penalty='l1' and
        linear_model.LogisticRegression with penalty='l1'.
        
        This value is valid if class_weight parameter in fit() is not set.
        
        Parameters
        ----------
        X : array-like or sparse matrix, shape = [n_samples, n_features]
            Training vector, where n_samples in the number of samples and
            n_features is the number of features.
        
        y : array, shape = [n_samples]
            Target vector relative to X
        
        loss : {'squared_hinge', 'log'}, default 'squared_hinge'
            Specifies the loss function.
            With 'squared_hinge' it is the squared hinge loss (a.k.a. L2 loss).
            With 'log' it is the loss of logistic regression models.
            'l2' is accepted as an alias for 'squared_hinge', for backward
            compatibility reasons, but should not be used in new code.
        
        fit_intercept : bool, default: True
            Specifies if the intercept should be fitted by the model.
            It must match the fit() method parameter.
        
        intercept_scaling : float, default: 1
            when fit_intercept is True, instance vector x becomes
            [x, intercept_scaling],
            i.e. a "synthetic" feature with constant value equals to
            intercept_scaling is appended to the instance vector.
            It must match the fit() method parameter.
        
        Returns
        -------
        l1_min_c : float
            minimum value for C

DATA
    __all__ = ['LinearSVC', 'LinearSVR', 'NuSVC', 'NuSVR', 'OneClassSVM', ...

FILE
    /Users/jack/miniconda2/envs/py37/lib/python3.6/site-packages/sklearn/svm/__init__.py


